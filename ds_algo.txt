Elshad Karimov from AppMillers
Java Data Structures and
Algorithms Masterclass
Learning Data Structures and Algorithms
Elshad Karimov from AppMillers
Java Data Structures and Algorithms
Masterclass
43 Sections
400+ Lectures
45+ hours of Content
100+ Downloadable resources
100+ Top Interview Questions
What is a Data Structure?
What is a Data Structure?
Data Structures are different ways of organizing data on your computer, that can be used effectively.
What is a Data Structure?
Data Structures are different ways of organizing data on your computer, that can be used effectively.
What is a Data Structure?
Data Structures are different ways of organizing data on your computer, that can be used effectively.
What is an Algorithm?
What is an Algorithm?
Set of instructions to perform a Task
Step 1: Choosing flooring Step 2: Purchase and bring
Step 5: Trim door casing Step 4: Determine the layout Step 3: Prepare sub flooring
What is an Algorithm?
Algorithms in our daily lives
Step 1 : Go to bus stop
Step 2 : Take a bus
Step 3: Go to office
What is an Algorithm?
Algorithms in our daily lives
Step 1 : Go to Starbucks
Step 2 : Pay money
Step 3: Take a coffee
What is an Algorithm?
Algorithms in Computer Science : Set of rules for a computer program to accomplish a Task
Input Data
Calculation
Stop when answer found
What is an Algorithm?
Sample Algorithms that are used by BIG Companies
How do Google and Facebook transmit live video across the internet?
Compression algorithms
What is an Algorithm?
Sample Algorithms that are used by BIG Companies
How to find the shortest path on the map?
Graph algorithms
What is an Algorithm?
Sample Algorithms that are used by BIG Companies
How to arrange solar panels on the International Space Station?
Optimization and scheduling algorithms
What is an Algorithm?
What makes a good algorithm?
-Correctness
-Efficiency
Why are Data Structures and Algorithms important?⚠
Why are Data Structures and Algorithms important?
Why are Data Structures and Algorithms important?
Input data
Processing
Output
Data Structures and Algorithms
Why are Data Structures and Algorithms important?
Algorithms
COMPUTER SCIENCE
ALGORITHMS
Algorithms
Why are Data Structures and Algorithms important?
Why are Data Structures and Algorithms important?
Algorithms
COMPUTER SCIENCE
ALGORITHMS
Algorithms
Data
Data Structure
Algorithm
Why are Data Structures and Algorithms in INTERVIEWS?
- Problem solving skills
- Fundamental concepts of programming in limited time
Types of Data Structure
Types of Data Structure
Primitive Non Primitive
Integer
Float
Character
String
Linear Non Linear
Tree
Graph Static Dynamic
Array Linked List
Stack
Queue
Boolean
Types of Data Structure
DATA STRUCTURE Description Example
INTEGER Numbers with our decimal point 1, 2, 3, 4, 5,1000
FLOAT Numbers with decimal point 3.5, 6.7, 6.987, 20.2
CHARACTER Single Character A, B, C, F
STRING Text Hello, Data Structure
BOOLEAN Logical values true or false TRUE, FALSE
Types of Algorithms
Types of Algorithms
- Simple recursive algorithms
- Divide and conquer algorithms
- Dynamic programming algorithms
- Greedy algorithms
- Brute force algorithms
- Randomized algorithms
Types of Algorithms
Simple recursive algorithms
Algorithm Sum(A, n)
 if n=1
 return A[0]
 s = Sum(A, n-1) /* recurse on all but last */
 s = s + A[n-1] /* add last element */
return s
Types of Algorithms
Divide and conquer algorithms
- Divide the problem into smaller subproblems of the same type, and solve these subproblems recursively
- Combine the solutions to the subproblems into a solution to the original problem
Examples: Quick sort and merge sort
Dynamic programming algorithms
- They work based on memoization
- To find the best solution
Types of Algorithms
Greedy algorithms
- We take the best we can without worrying about future consequences.
- We hope that by choosing a local optimum solution at each step, we will end up at a global optimum solution
Brute force algorithms
- It simply tries all possibilities until a satisfactory solution is found
Randomized algorithms
- Use a random number at least once during the computation to make a decision
Recursion
- What is Recursion?
- Why do we need Recursion?
- The Logic behind the Recursion
- Recursive vs Iterative Solutions
- How to Write Recursion in 3 Steps?
- Find Fibonacci Series using Recursion
Recursion
Objectives:
What is Recursion?
What is Recursion?
Recursion : a way of solving a problem by having a function calling itself
…
What is Recursion?
- Performing the same operation multiple times with different inputs
- In every step we try smaller inputs to make the problem smaller.
- Base condition is needed to stop the recursion, otherwise infinite loop will occur.
Recursion : a way of solving a problem by having a function calling itself
What is Recursion?
Recursion : a way of solving a problem by having a function calling itself
static void openRussianDoll(int doll) {
 if (doll == 1) {
 System.out.println("All dolls are opened");
 } else {
 openRussianDoll(doll-1);
 }
 }
Why we need Recursion?
Why we need Recursion?
1. Recursive thinking is really important in programming and it helps you break down big
problems into smaller ones and easier to use
‣ If you can divine the problem into similar sub problems
‣ Design an algorithm to compute nth…
‣ Write code to list the n…
‣ Implement a method to compute all.
‣ Practice
- when to choose recursion?
2. The prominent usage of recursion in data structures like trees and graphs.
4. It is used in many algorithms (divide and conquer, greedy and dynamic programming)
3. Interviews
The Logic Behind Recursion
The Logic Behind Recursion
1. A method calls it self
2. Exit from infinite loop
 static string recursionMethod(String[] parameters) {
 if (exit from condition satisfied) {
 return some value;
 } else {
 recursionMethod(modified parameters);
 }
 }
 static void firstMethod() {
 secondMethod();
 System.out.println("I am the first Method");
 }
 static void secondMethod() {
 thirdMethod();
 System.out.println("I am the second Method");
 }
 static void thirdMethod() {
 fourthMethod();
 System.out.println("I am the third Method");
 }
 static void fourthMethod() {
 System.out.println("I am the fourth Method");
 }
STACK Memory
firstMethod()
secondMethod()
thirdMethod()
The Logic Behind Recursion
STACK Memory
recursiveMethod(3)
recursiveMethod(2)
recursiveMethod(1)
recursiveMethod(4)
recursiveMethod(4)
recursiveMethod(3)
recursiveMethod(2)
recursiveMethod(1)
recursiveMethod(0) n is less than 1
1
2
3
4
 static void recursiveMethod(int n) {
 if (n<1) {
 System.out.println("n is less than 1");
 } else {
 recursiveMethod(n-1);
 System.out.println(n);
 }
 }
The Logic Behind Recursion
Recursive vs Iterative Solutions
Recursive vs Iterative Solutions
static int powerOfTwo(int n) {
 if (n==0) {
 return 1;
 } else {
 var power = 2*powerOfTwo(n-1);
 return power;
 }
 }
static int powerOfTwoIT(int n) {
 var i = 0;
 var power = 1;
 while (i < n) {
 power = power * 2;
 i = i + 1;
 }
 return power;
 }
Points Recursion Iteration
Space efficient? No Yes No stack memory require in case of iteration
Time efficient? No Yes In case of recursion system needs more time for pop and push
elements to stack memory which makes recursion less time
efficient
Easy to code? Yes No We use recursion especially in the cases we know that a
problem can be divided into similar sub problems.
Recursive Iterative
When to Use/Avoid Recursion?
!
When to Use/Avoid Recursion?
When to use it?
- When we use memoization in recursion
- When we can easily breakdown a problem into similar subproblem
- When we are fine with extra overhead (both time and space) that comes with it
- When we need a quick working solution instead of efficient one
- When traverse a tree
- Recursion can be slow
When avoid it?
- If time and space complexity matters for us.
- Recursion uses more memory. If we use embedded memory. For example an application
that takes more memory in the phone is not efficient
15
9 23
3 12 17 28
1 4
- preorder tree traversal : 15, 9, 3, 1, 4, 12, 23, 17, 28
Write Recursion in 3 Steps
Write Recursion in 3 Steps
Factorial
- It is the product of all positive integers less than or equal to n.
- Denoted by n! (Christian Kramp in 1808).
- Only positive numbers.
- 0!=1.
n! = n*(n-1)*(n-2)*…*2*1
4! = 4*3*2*1=24
10! = 10*9*8*7*6*5*4*3*2*1=36,28,800
Example 1
Example 2
!
Write Recursion in 3 Steps
n! = n * (n-1) * ( n-2) * … * 2 * 1
(n-1)!
(n-1)! = (n-1) * (n-1-1) * (n-1-2) * … * 2 * 1 = (n-1) * (n-2) * (n-3) * … * 2 * 1
Step 1 : Recursive case - the flow
n! = n * (n-1)!
Step 2 : Base case - the stopping criterion
0! = 1
1! = 1
Step 3 : Unintentional case - the constraint
factorial(-1) ??
factorial(-2) ??
Write Recursion in 3 Steps
public int factorial(int n) {
 if (n<0) {
 return -1;
 }
 if (n == 0 || n == 1) {
 return 1;
 }
 return n * factorial(n-1);
 }
factorial(4)
4 * factorial(3)
3 * factorial(2)
2 * factorial(1)
1
2
6
factorial(4) = 24
Fibonacci using Recursion
Write Fibonacci Recursion in 3 Steps
Fibonacci numbers
- Fibonacci sequence is a sequence of numbers in which each number is the sum of the two
preceding ones and the sequence starts from 0 and 1
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…
5 = 3 + 2
Step 1 : Recursive case - the flow
Step 2 : Base case - the stopping criterion
0 and 1
Step 3 : Unintentional case - the constraint
fibonacci(-1) ??
fibonacci(1.5) ??
f(n) = f(n-1) + f(n-2)
Write Fibonacci Recursion in 3 Steps
fibonacci(4)
fibonacci(3) + fibonacci(2)
fibonacci(2) + fibonacci(1)
0
2
public int fibonacci(int n) {
 if (n < 0) {
 return -1;
 }
 if (n == 0 || n == 1) {
 return n;
 }
 return fibonacci(n-1) + fibonacci(n-2);
 }
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…
fibonacci(1) + fibonacci(0)
1
1
1
1
=3
0
fibonacci(1) + fibonacci(0)
1
Recursion Interview
Questions
Recursion Interview Questions
Recursion Interview Questions - 1
How to find the sum of digits of a positive integer number using recursion ?
10
Step 1 : Recursive case - the flow
Step 2 : Base case - the stopping criterion
n =0
Step 3 : Unintentional case - the constraint
sumofDigits(-11) ??
sumofDigits(1.5) ??
10/10 = 1 and Remainder = 0 f(n) = n%10 + f(n/10)
54 54/10 = 5 and Remainder = 4
112 112/10 = 11 and Remainder = 2
11/10 = 1 and Remainder = 1
Recursion Interview Questions - 2
xn=x*x*x*..(n times)..*x
Step 1 : Recursive case - the flow
Step 2 : Base case - the stopping criterion
n = 0
n = 1
Step 3 : Unintentional case - the constraint
power(2, 1.2) ??
power(2, -1) ??
xn 24=2*2*2*2 = x * xn-1
xa * xb=xa+b
x3 * x4=x3+4
How to calculate power of a number using recursion?
Recursion Interview Questions - 3
GCD is the largest positive integer that divides the numbers without a remainder
Step 1 : Recursive case - the flow
Step 2 : Base case - the stopping criterion
b = 0
Step 3 : Unintentional case - the constraint
Positive integers
gcd(a, 0)=a
gcd(a, b) = gcd(b, a mod b)
gcd(8,12) = 4
8 = 2 * 2 * 2
12 = 2 * 2 * 3
How to find GCD ( Greatest Common Divisor) of two numbers using recursion?
Euclidean algorithm
gcd(48,18)
Step 1 : 48/18 = 2 remainder 12
Step 2 : 18/12 = 1 remainder 6
Step 3 : 12/6 = 2 remainder 0
Recursion Interview Questions - 4
Step 1 : Recursive case - the flow
f(n) = n mod 2 + 10 * f(n/2)
How to convert a number from Decimal to Binary using recursion
Step 1 : Divide the number by 2
Step 2 : Get the integer quotient for the next iteration
Step 3 : Get the remainder for the binary digit
Step 3 : Repeat the steps until the quotient is equal to 0
Division by 2 Quotient Remainder
13/2 6 1
6/2 3 0
3/2 1 1
1/2 0 1
13 to binary
Division by 2 Quotient Remainder
10/2 5 0
5/2 2 1
2/2 1 0
1/2 0 1
10 to binary
1 * 10 + 0 = 10
10 * 10 + 1 = 101
101 * 10 + 0 = 1010
1101010
Big O
- What is Recursion?
- Why do we need Recursion?
- The Logic behind the Recursion
- Recursive vs Iterative Solutions
- How to Write Recursion in 3 Steps?
- Find Fibonacci Series using Recursion
Big O
Objectives:
What is Big O?
What is Big O?
Big O is the language and metric we use to describe the efficiency of algorithms.
�
Size : 1TB
?
Internet
Time Complexity : A way of showing how the runtime of a function increases as the size of input increases.
What is Big O?
Big O is the language and metric we use to describe the efficiency of algorithms.
Physical - O(1)
Electronic - O(s)
Time Complexity : A way of showing how the runtime of a function increases as the size of input increases.
Types of Runtimes:
O(N), O(N2), O(2N)
Time complexity : O(wh)
w
h
What is Big O?
What is Big O?
Big O Notations
Big O Notations
- City traffic - 20 liters
- Highway - 10 liters
- Mixed condition - 15 liters
Big O Notations
- Best case
- Average case
- Worst case
Big O Notations
Quick sort algorithm
O(N)
O(N2) O(N log N)
Big O Notations
- Big O : It is a complexity that is going to be less or equal to the worst case.
- Big - Ω (Big-Omega) : It is a complexity that is going to be at least more than the best case.
- Big Theta (Big - Θ) : It is a complexity that is within bounds of the worst and the best cases.
5 4 10 … 8 11 68 87 12 … 90 13 77 55 9
n
Big O - O(N)
Big Ω - Ω(1)
Big Θ - Θ(n/2)
Runtime Complexities
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(1) - Constant time
int[] array = {1, 2, 3, 4, 5}
array[0] // It takes constant time to access first element
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(1) - Constant time random card
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(N) - Linear time
int[] custArray = {1, 2, 3, 4, 5}
for (int i = 0; i < custArray.length; i++) {
 System.out.println(custArray[i]);
}
//linear time since it is visiting every element of array
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(N) - Linear time Specific card
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(Log N) - Logarithmic time
int[] custArray = {1, 2, 3, 4, 5}
for (int i = 0; i < custArray.length; i+3) {
 System.out.println(custArray[i]);
}
//logarithmic time since it is visiting only some elements
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(Log N) - Logarithmic time
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(Log N) - Logarithmic time
Binary search
search 9 within [1,5,8,9,11,13,15,19,21]
compare 9 to 11 → smaller
search 9 within [1,5,8,9]
compare 9 to 8 → bigger
search 9 within [9]
compare 9 to 9
return
N = 16
N = 8 /* divide by 2 */
N = 4 /* divide by 2 */
N = 2 /* divide by 2 */
N = 1 /* divide by 2 */
2k = N → log2N = k
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(N2) - Quadratic time
int[] custArray = {1, 2, 3, 4, 5}
for (int i = 0; i < custArray.length; i++) {
 for (int j = 0; j < custArray.length; j++) {
 System.out.println(custArray[i]);
 }
}
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(N2) - Quadratic time
Runtime Complexities
Complexity Name Sample
O(1) Constant Accessing a specific element in array
O(N) Linear Loop through array elements
O(LogN) Logarithmic Find an element in sorted array
O(N2) Quadratic Looking ar a every index in the array twice
O(2N) Exponential Double recursion in Fibonacci
O(2N) - Exponential time
public int fibonacci(int n) {
 if (n==0 || n==1) {
 return n;
 }
 return fibonacci(n-1) + fibonacci(n-2);
 }
Runtime Complexities
Space Complexity
Space Complexity
an array of size n an array of size n*n
O(n) O(n2)
Space Complexity
static int sum(int n) {
if (n <= 0) {
return 0;
}
return n + sum(n-1);
 }
1 sum(3)
2 → sum(2)
3 → sum(1)
4 → sum(0)
Space complexity : O(n)
Space Complexity
static int pairSumSequence(int n) {
 var sum = 0;
for (int i = 0; i <= n; i++) {
 sum = sum + pairSum(i, i+1);
}
return sum;
}
static int pairSum(int a, int b) {
return a + b;
 }
Space complexity : O(1)
Drop Constants and Non Dominant Terms
Drop Constants and Non Dominant Terms
Drop Constant
Drop Non Dominant Terms
O(2N) O(N)
O(N2+N) O(N2)
O(N+logN) O(N)
O(2*2N+1000N100) O(2N)
Drop Constants and Non Dominant Terms
- It is very possible that O(N) code is faster than O(1) code for specific inputs
- Different computers with different architectures have different constant factors.
- Different algorithms with the same basic idea and computational complexity might have
slightly different constants
Fast computer
Fast memory access
Lower constant
Slow computer
Slow memory access
Higher constant
Example: a*(b-c) vs a*b - a*c
- As 𝑛→∞, constant factors are not really a big deal
Add vs Multiply
for (a=0; arrayA.length; a++) {
 System.out.println(arrayA[a]);
}
for (b=0; arrayB.length; b++) {
 System.out.println(arrayB[b]);
}
for (a=0; arrayA.length; a++) {
 for (b=0; arrayB.length; b++) {
 System.out.println(arrayB[b] + arrayA[a]);
 }
}
Add the Runtimes: O(A + B) Multiply the Runtimes: O(A * B)
- If your algorithm is in the form “do this, then when you are all done, do that” then you add the runtimes.
- If your algorithm is in the form “do this for each time you do that” then you multiply the runtimes.
How to measure the codes using Big O?
How to measure the codes using Big O?
No Description Complexity
Rule 1 Any assignment statements and if statements that are executed once regardless of the size of
the problem O(1)
Rule 2 A simple “for” loop from 0 to n ( with no internal loops) O(n)
Rule 3 A nested loop of the same type takes quadratic time complexity O(n2)
Rule 4 A loop, in which the controlling parameter is divided by two at each step O(log n)
Rule 5 When dealing with multiple statements, just add them up
Public static void findBiggestNumber([] sampleArray) {
 var biggestNumber = sampleArray[0];
 for (index=1; sampleArray.length; index++) {
 if (sampleArray[index] > biggestNumber) {
 biggestNumber = sampleArray[index];
 }
 }
 System.out.println(biggestNumber);
}
O(1)
O(n)
O(1)
O(1)
O(1)
} O(1)} O(n)
Time complexity : O(1) + O(n) + O(1) = O(n)
sampleArray 5 4 10 … 8 11 68 87 …
How to measure Recursive Algorithm?
How to measure Recursive Algorithm?
sampleArray 5 4 10 … 8 11 68 87 10
public int findMaxNumRec(int [] sampleArray, int n):
 if (n == 1) {
 return sampleArray[0];
 }
 return max(sampleArray[n-1],findMaxNumRec(sampleArray, n-1));
Explanation:
A = 11 4 12 7 n = 4
findMaxNumRec(A,4)
findMaxNumRec(A,3)
findMaxNumRec(A,2)
findMaxNumRec(A,1) A[0]=11
max(A[2-1],11) max(4,11)=11
max(A[3-1],11) max(12,11)=12
max(A[4-1],12) max(7,12)=12
How to measure Recursive Algorithm?
sampleArray 5 4 10 … 8 11 68 87 10
public int findMaxNumRec(int [] sampleArray, int n):
 if (n == 1) {
 return sampleArray[0];
 }
 return max(sampleArray[n-1],findMaxNumRec(sampleArray, n-1));
M(n)
O(1)
O(1)
M(n-1)
M(n)=O(1)+M(n-1)
M(1)=O(1)
M(n-1)=O(1)+M((n-1)-1)
M(n-2)=O(1)+M((n-2)-1)}
M(n)=1+M(n-1)
=1+(1+M((n-1)-1))
=2+M(n-2)
=2+1+M((n-2)-1)
=3+M(n-3)
=a+M(n-a)
.
.
=n-1+M(n-(n-1))
=n-1+1
=n
How to measure Recursive Algorithm
with multiple calls?
How to measure Recursive Algorithm with multiple calls?
public int findMaxNumRec(int [] sampleArray, int n):
 if (n == 1) {
 return sampleArray[0]; }
 return max(sampleArray[n-1],findMaxNumRec(sampleArray, n-1));
public int f(int n):
 if (n <= 1) {
 return 1; }
 return f(n-1) + f(n-1);
How to measure Recursive Algorithm with multiple calls?
public int f(int n):
 if (n <= 1) {
 return 1; }
 return f(n-1) + f(n-1);
f(4)
f(3) f(3)
f(2) f(2) f(2) f(2)
f(1) f(1) f(1) f(1) f(1) f(1) f(1) f(1)
N Level Node# Also can be expressed.. or..
4 0 1 20
3 1 2 2 * previous level = 2 21
2 2 4 2 * previous level = 2 *21=22 22
1 3 8 2 * previous level = 2 *22=23 23
0
1
2
3
Level
O(branchesdepth)
20+21+22+…+2n=2n+1-1
2n-1 O(2n)
Big O Interview
Questions
O(n)
Interview Question 1
- Create a function which calculates the sum and product of elements of array
- Find the time complexity for created method.
Interview Question 2
- Create a function which prints to the console the pairs from given array.
- Find the time complexity for created method.
[1,3,4,5] 11, 13, 14, 15
31, 33, 34, 35
41, 43, 44, 45
51, 53, 54, 55
Interview Question 3 - What is the time complexity for this method?
[1,3,4,5] 13, 14, 15
34, 35
45
void printUnorderedPairs(int[] array) {
 for (int i=0; i<array.length; i++) {
 for (int j=i+1; j<array.length; j++) {
 System.out.println(array[i] + ", "+ array[j]);
 }
 }
 }
}
Interview Question 3 - What is the time complexity for this method?
void printUnorderedPairs(int[] array) {
 for (int i=0; i<array.length; i++) {
 for (int j=i+1; j<array.length; j++) {
 System.out.println(array[i] + ", "+ array[j]);
 }
 }
 }
Time Complexity : O(N2)
1. Counting the iterations
1st
2nd
n-1
n-2 .
.
1
(n-1)+(n-2)+(n-3)+..+2+1
=1+2+…+(n-3)+(n-2)+(n-1)
=n(n-1)/2
=n2/2 - n/2
=n2
2. Average Work
Outer loop - N times
Inner loop?
1st
2nd
10
9 .
.
1
= 5 10/2
n n/2
n*n/2 = n2/2 O(N2)
Interview Question 4
void printUnorderedPairs (int[] arrayA, int[] arrayB) {
 for (int i=0; i < arrayA.length; i++) {
 for (int j=0; j < arrayB.length; j++) {
 if (arrayA[i] < arrayB[j]) {
 System.out.println(arrayA[i] + "," + arrayB[j]);
 }
 }
 }
 }
void printUnorderedPairs (int[] arrayA, int[] arrayB) {
 for (int i=0; i < arrayA.length; i++) {
 for (int j=0; j < arrayB.length; j++) {
 O(1) }
 }
 }
Time Complexity : O(ab)
a = arrayA.length;
b = arrayB.length;
What is the runtime of the below code?
} O(ab)
Interview Question 5
void printUnorderedPairs (int[] arrayA, int[] arrayB) {
 for (int i=0; i < arrayA.length; i++) {
 for (int j=0; j < arrayB.length; j++) {
 for (int k = 0; k<1000000; k++) {
 System.out.println(arrayA[i] + "," + arrayB[j]);
 }
 }
 }
 }
Time Complexity : O(ab)
b = arrayB.length;
a = arrayA.length;
What is the runtime of the below code?
100,000 units of work is still constant
} O(ab)
O(1)
O(1) ?
Interview Question 6
- Create a method which takes an array as a parameter and reverses it.
- Find the runtime of the created method?
1 2 3 4 5 5 4 3 2 1
input output
Interview Question 7
Which of the following are equivalent to O(N)? Why?
1. O(N + P) , where P < N/2
2. O(2N)
3. O(N+logN)
4. O(N + NlogN)
5. O(N+M)
O(N)
O(N)
O(N)
O(NlogN)
Interview Question 8
What is the runtime of the below code?
static int factorial(int n) {
 if (n < 0) {
 return -1;
 } else if (n == 0) {
 return 1;
 } else {
 return n * factorial(n-1);
 }
 }
Time Complexity : O(N)
n! = 1*2*3*…*n
3! = 1*2*3=6
M(n)=O(1)+M(n-1)
M(1)=O(1)
M(n-1)=O(1)+M((n-1)-1)
M(n-2)=O(1)+M((n-2)-1)}
M(n)=1+M(n-1)
=1+(1+M((n-1)-1))
=2+M(n-2)
=2+1+M((n-2)-1)
=3+M(n-3)
=a+M(n-a)
.
.
=n+M(n-n)
=n+1
=n
M(n)
O(1)
M(n-1)
}
Interview Question 9
void allFib(int n) {
 for (i=0; i<n; i++) {
 fib(i);
 }
 }
static int fib(int n) {
 if (n<=0) {
 return 0;
 } else if (n==1) {
 return 1;
 } else {
 return fib(n-1) + fib(n-2);
 }
 }
branchesdepth O(2N)
Time Complexity : O(2N)
fib(1) 21 steps
fib(2) 22 steps
fib(3) 23 steps
fib(4) 24 steps
fib(n) 2n steps
…
Total work = 21+22+23+24+…+2n
= 2n+1-2
What is the runtime of the below code?
Interview Question 10
What is the runtime of the below code?
 static int powersOf2(int n) {
 if (n<1) {
 return 0;
 } else if (n==1) {
 System.out.println(1);
 return 1;
 } else {
 var prev = powersOf2(n/2);
 var curr = prev*2;
 System.out.println(curr);
 return curr;
 }
 }
Time Complexity : O(logN)
n=50
powersOf(50)
} O(1)
} O(1)
powersOf(25)
powersOf(12)
powersOf(6)
powersOf(3)
powersOf(1) return 1
return 2
return 4
return 8
return 16
return 32
x2
Arrays
Arrays
Arrays
- It is a box of macaroons.
- All macaroons in this box are next to each other
- Each macaroon can be identified uniquely based on their location
- The size of box cannot be changed
4 3 1 6 8 10
- Array can store data of specified type
- Elements of an array are located in a contiguous
- Each element of an array has a unique index
- The size of an array is predefined and cannot be modified
[0] [1] [2] [3] [4] [5]
“a”
What is an Array?
- What if 500 integer?
- Are we going to use 500 variables?
The answer is an ARRAY
3 variables
number1
number2
number3
In computer science, an array is a data structure consisting of a collection of elements , each identified by at
least one array index or key. An array is stored such that the position of each element can be computed
from its index by a mathematical formula.
4 3 1 6 8 10
[0] [1] [2] [3] [4] [5]
Why do we need an Array?
Types of Arrays
Types of Arrays
Arrays
One Dimensional Multi dimensional
Two dimensional
Three dimensional
Four dimensional
N dimensional
.
.
.
Types of Arrays
5 4 10 11 8 11 68 87 12
One dimensional array : an array with a bunch of values having been declared with a single index.
a[i] —> i between 0 and n
Two dimensional array : an array with a bunch of values having been declared with double index.
1 33 55 91 20 51 62 74 13
5 4 10 11 8 11 68 87 12
24 50 37 40 48 30 59 81 93
Three dimensional array : an array with a bunch of values having been declared with triple index.
a[i][j] —> i and j between 0 and n
a[i][j][k] —> i , j and k between 0 and n
[0] [1] [2] [3] [4] [5] [6] [7] [8]
[0] [1] [2] [3] [4] [5] [6] [7] [8]
[0]
[1]
[2]
a[2] a[5]
a[0][4] a[2][5]
a[0][0][1]
a[2][0][2]
Types of Arrays
5 4 10 11 8 11 68 87 12
One dimensional array :
Two dimensional array :
1 33 55 91 20 51 62 74 13
5 4 10 11 8 11 68 87 12
24 50 37 40 48 30 59 81 93
Three dimensional array :
Arrays in Memory
Arrays in Memory
5 4 10 11 8 11 68 87 12
5 4 10 11 8 11 68 87 12
One Dimensional
Memory
Arrays in Memory
1 2 3
4 5 6
7 8 9
1 2 3 4 5 6 7 8 9
Two Dimensional array
Memory
Row 1
Row 2
Row 3
Arrays in Memory
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
Three Dimensional array
Memory
{{{ 0, 1, 2},
 { 3, 4, 5},
 { 6, 7, 8},
 { 9, 10, 11},
 { 12, 13, 14},
 { 15, 16, 17}}};
Creating an Array
When we create an array , we:
- Declare - creates a reference to array
- Instantiation of an array - creates an array
- Initialization - assigns values to cells in array
Memory
arr
Creating an Array
When we create an array , we:
- Declare - creates a reference to array
- Instantiation of an array - creates an array
- Initialization - assigns values to cells in array
0 0 0 0 0
Memory
arr
xx11
xx11
xx11+0 xx11+1 xx11+2
Creating an Array
When we create an array , we:
- Declare - creates a reference to array
- Instantiation of an array - creates an array
- Initialization - assigns values to cells in array
10 10 10 10 10
Memory
arr
xx11
xx11
xx11+0 xx11+1 xx11+2
Creating an Array
When we create an array , we:
- Declare - creates a reference to array
- Instantiation of an array - creates an array
- Initialization - assigns values to cells in array
dataType[] arr
arr = new dataType[]
arr[0] = 1
arr[1] = 2
Insertion in Array
myArray = “a” “b” “c”
myArray[3] = “d”
myArray[5] = “f”
“d” “f”
[0] [1] [2] [3] [4] [5]
“a” “b” “c” “d” “e”
[0] [1] [2] [3] [4] [5]
Insertion in Array
“f”
“a” “b” “c” “d” “e”
[0] [1] [2] [3] [4] [5]
“f” “a” “b” “c” “d” “e”
[0] [1] [2] [3] [4] [5]
Insertion in Array
“f”
“a” “b” “c” “d” “e” “h”
[0] [1] [2] [3] [4] [5]
Insertion in Array
⚠ Wait A minute! What Happens if the Array is Full?
“f”
�FULL❗
“a” “b” “c” “d” “e” “h”
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12]
“a” “b” “c” “d” “e” “h”
[0] [1] [2] [3] [4] [5]
Insertion in Array
Insertion , when an array is full.
“a” “b” “c” “d” “e” “f”
[0] [1] [2] [3] [4] [5]
Array Traversal
myArray =
myArray[0] = “a”
myArray[1] = “b”
myArray[2] = “c”
myArray[3] = “d”
myArray[4] = “e”
myArray[5] = “f”
Accessing Array Element
1 2 3 4 5
Memory
arr
xx11
xx11
xx11+0 xx11+1 xx11+2
Accessing Array Element
INDEX [0] [1] [2] [3] [4] [5]
<arrayName>[index]
Accessing Array Element
For example:
“a” “b” “c” “d” “e” “f”
[0] [1] [2] [3] [4] [5]
myArray =
myArray[0] = “a”
myArray[3] = “d”
Finding Array Element
myArray = “a” “b” “c” “d” “e” “h”
myArray2 = 1 2 3 4 5 6 7 8 9
[0] [1] [2] [3] [4] [5]
Finding Array Element
“a” “b” “c” “d” “e” “h”
[0] [1] [2] [3] [4] [5]
Is this the element?
10 20 30 40
[0] [1] [2] [3] [4] [5]
Deleting Array Element
Integer.MIN_VALUE
-231 -231 -231
Time and Space Complexity of 1D Arrays
Operation Time complexity Space complexity
Creating an empty array O(1) O(n)
Inserting a value in an array O(1) O(1)
Traversing a given array O(n) O(1)
Accessing a given cell O(1) O(1)
Searching a given value O(n) O(1)
Deleting a given value O(1) O(1)
Find Number of Days Above Average Temperature
How many day's temperature?
Day 1’s high temp:
Day 2’s high temp:
2
1
2
Average = 1.5
1 day(s) above average
Output
1 33 55 91 20 51 62 74 13
5 4 10 11 8 11 68 87 12
24 50 37 40 48 30 59 81 93
Two Dimensional Array
An array with a bunch of values having been declared with double index.
a[i][j] —> i and j between 0 and n
Day 1 - 11, 15, 10, 6
Day 2 - 10, 14, 11, 5
Day 3 - 12, 17, 12, 8
Day 4 - 15, 18, 14, 9
[0] [1] [2] [3] [4] [5] [6] [7] [8]
[0]
[1]
[2]
a[0][4] a[2][5]
0 0 0 0 0 0
Two Dimensional Array
When we create an array , we:
- Declare - creates a reference to array
- Instantiation of an array - creates an array
- Initialization - assigns values to cells in array
10 20 30 40 50 60
Memory
arr
xx11
xx11
xx11+0 xx11+1 xx11+2
10 20 30
40 50 60
Insertion - Two Dimensional Array
[0] [1] [2] [3] [4] [5] [6] [7] [8]
[0]
[1]
[2]
arrayName[2][5] = 30
arrayName[0][0] = 50
30
50
arrayName[0][0] = 60 Occupied
Access an element of Two Dimensional Array
1 33 55 91 20 51 62 74 13
5 4 10 11 8 11 68 87 12
24 50 37 40 48 30 59 81 93
a[i][j] —> i is row index and j is column index
[0] [1] [2] [3] [4] [5] [6] [7] [8]
[0]
[1]
[2]
a[0][4]
a[2][5]
Traversing Two Dimensional Array
1 33 55 91
5 4 10 11
24 50 37 40
1 33 55 91 5 4 10 11 24 50 37 40
Searching Two Dimensional Array
1 33 55 91
5 4 44 11
24 50 37 40
Is this the element?
The element is found at [1][2]
Searching for 44
1 33 55 91
5 4 10 11
24 50 37 40
Deleting Array Element in 2D Array
-231
[0] [1] [2] [3]
[0]
[1]
[2]
arrayName[2][3] = Integer.MIN_VALUE
arrayName[1][1] = Integer.MIN_VALUE
-231
Time and Space Complexity of 2D Array
Operation Time complexity Space complexity
Creating an empty array O(1) O(mn)
Inserting a value in an array O(1) O(1)
Traversing a given array O(mn) O(1)
Accessing a given cell O(1) O(1)
Searching a given value O(mn) O(1)
Deleting a given value O(1) O(1)
When to use/avoid Arrays
When to use
When to avoid
- To store multiple variables of same data type
- Random access
- Same data type elements
- Reserve memory
When to use/avoid Arrays
When to use
When to avoid
- To store multiple variables of same data type
- Random access
- Same data type elements
- Reserve memory
Array Project
Array Project
Find Number of Days Above Average Temperature
How many day's temperature?
Day 1’s high temp:
Day 2’s high temp:
2
1
2
Average = 1.5
1 day(s) above average
Output
Array Interview
Questions
Missing Number
Find the missing number in an integer array of 1 to 100
1,2,3,4,5,6…50,51,52..100
1,2,3,4,5,6,7,8,9,10
1,2,3,4,5,6,8,9,10
= 55
= 48
7
1,2,3,4,5,6…n = n(n+1)/2
Pairs / Two Sum
Write a program to find all pairs of integers whose sum is equal to a given number.
[2, 6, 3, 9, 11] 9 [6,3]
Pairs / Two Sum
Write a program to find all pairs of integers whose sum is equal to a given number.
[2, 6, 3, 9, 11] 9 [6,3]
- Does array contain only positive or negative numbers?
- What if the same pair repeats twice, should we print it every time?
- If the reverse of the pair is acceptable e.g. can we print both (4,1) and (1,4) if the given sum is 5.
- Do we need to print only distinct pairs? does (3, 3) is a valid pair forgiven sum of 6?
- How big is the array?
20 10 30 50 40 60
[0] [1] [2] [3] [4] [5]
Search for a Value
Write a program to to check if an array contains a number in Java
Is this the element?
Searching for 40 Found at the index of 4
20 10 30 50 40 60
[0] [1] [2] [3] [4] [5]
Max Product of Two Integers
Write a program to find maximum product of two integers in the array where
all elements are positive
maxProduct = 0
20 10 30 50 40 60
[0] [1] [2] [3] [4] [5]
Is Unique
Write a program to check if an array is unique or not.
isUnique True
2 1 3 5 4 6
Permutation
Your are given two integer arrays. Write a program to check if they are permutation of each
other.
Permutation True
1 3 2 4 6 5
sum1 = 21
sum2 = 21
mul1 = 720
mul2 = 720
Rotate Matrix
Given an image represented by an NxN matrix write a method to rotate the image by 90
degrees.
1 2 3
4 5 6
7 8 9
1 2 3
4 5 6
7 8 9
Rotate 90 degrees
Rotate Matrix
Given an image represented by an NxN matrix write a method to rotate the image by 90
degrees.
1 2 3
4 5 6
7 8 9
7 2 1
4 5 6
9 8 3
7 4 1
8 5 2
9 6 3
for i = 0 to n
 temp = top[i]
 top[i] = left[i]
 left[i] = bottom[i]
 bottom[i] = right[i]
 right[i] = temp
Rotate Matrix
Given an image represented by an NxN matrix write a method to rotate the image by 90
degrees.
Linked List
www.appmillers.com
What is a Linked List?
 Linked List is a form of a sequential collection and it does not have to be in order. A Linked list is made up of independent nodes
that may contain any type of data and each node has a reference to the next node in the link.
Cars (nodes)
Links
Head
Tail
- Each car is independent
- Cars : passengers and links (nodes: data and links)
www.appmillers.com
What is a Linked List?
Cars (nodes)
Links
Head
Tail
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail
Nodes : data and references
Linked List vs Array
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
0 1 2 3 4 5
- Elements of Linked list are independent objects
- Variable size - the size of a linked list is not predefined
Linked List =
Array =
- Random access - accessing an element is very efficient in arrays
Types of Linked List
www.appmillers.com
- Singly Linked List
- Circular Singly Linked List
- Doubly Linked List
- Circular Doubly Linked List
Head 001 1 111 2 222 4 333 5 001
001 111 222 333
Tail 333
Circular Singly Linked List
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
Singly Linked List
Types of Linked List
www.appmillers.com
Head 001 Player1 111 Player2 222 Player3 333 Player4 001
001 111 222 333
Tail 333
Circular Singly Linked List
Types of Linked List
www.appmillers.com
Head 001 null 1 111
001 111 222 333
Tail 333
Doubly Linked List
001 2 222 111 4 333 222 5 null
Types of Linked List
www.appmillers.com
Head 001 null S1 111
001 111 222 333
Tail 333
001 S2 222 111 S3 333 222 S4 null
Types of Linked List
www.appmillers.com
Circular Doubly Linked List
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
Types of Linked List
www.appmillers.com
Head 001 333 APP1 111
001 111 222 333
Tail 333
001 APP2 222 111 APP3 333 222 APP4 001
Cmd+shift+tab
Linked List in Memory
www.appmillers.com
Arrays in memory : 0 1 2 3 4 5
0 1 2 3 4 5
Memory
Linked List in Memory
www.appmillers.com
Linked list:
2
4
5 1
Memory
Head 1 1 111 2 222 4 333 5 null
Tail Head
Creation of Singly Linked List
www.appmillers.com
1 null
Head
Tail
Node
Create Head and Tail, initialize with null
Create a blank Node and assign a value to it
and reference to null.
Link Head and Tail with these Node
111
111
111
Creation of Singly Linked List
www.appmillers.com
Create Head and Tail, initialize with null
Create a blank Node and assign a value to it
and reference to null.
Link Head and Tail with these Node
O(1)
O(1)
O(1)
Insertion to Linked List in Memory
www.appmillers.com
1. At the beginning of the linked list.
2. After a node in the middle of linked list
3. At the end of the linked list.
Insertion to Linked List in Memory
www.appmillers.com
Insert a new node at the beginning
2
4
5 1
Memory
Head 1 1 111 2 222 4 333 5 null
Head
0
❌
0
Insertion to Linked List in Memory
www.appmillers.com
Insert a new node after a node
2
4
5 1
Memory
Head 1 1 111 2 222 4 333 5 null
Head
0
3
❌
3
Insertion to Linked List in Memory
www.appmillers.com
Insert a new node at the end of linked list
2
4
5 1
Memory
Head 1 1 111 2 222 4 333 5 null
Head
3 0
3
Insertion Algorithm
www.appmillers.com
Node value
Location head=None?
Terminate
- create node
- assign value
- node.next = head
- head = node Location = first
Location = last
- node.next = null
- last.next = node
- tail = node
- Find location (loop)
- current.next = node
- node.next =nextNode
Yes
No
Yes
No
Yes
- head = node
- tail = node
No
AppMillers
www.appmillers.com
Insertion Algorithm
Node value
Location head=None?
Terminate
- create node
- assign value
- node.next = head
- head = node Location = first
Location = last - node.next = null
- last.next = node
- tail = node
- Find location (loop)
- current.next = node
- node.next =nextNode
Yes
No
Yes
No
Yes
- head = node
- tail = node
No
AppMillers
www.appmillers.com
Singly Linked List Insertion at the beginning
- node.next = head
- head = node 6
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail
444
001 444
AppMillers
www.appmillers.com
Singly Linked List Insertion at the end
6
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail
444
null
444
- node.next = null
- last.next = node
- tail = node
AppMillers
www.appmillers.com
Singly Linked List Insertion in the middle
6
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail
444
333
444
- find location (loop)
- current.next = node
- node.next =nextNode
Traversal of Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
Start Check Head?
Terminate
- Loop all nodes
- Print value
No
Yes
Search in Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
Start Check Head?
nodeValue
Terminate
No
Yes
If nodeValue=currentNode
Yes
No
AppMillers
www.appmillers.com
Singly Linked list Deletion
Head 001 1 null
001
Tail 001
- Deleting the first node
- Deleting any given node
- Deleting the last node
Case 1 - one node
null
null
AppMillers
www.appmillers.com
Singly Linked list Deletion
- Deleting the first node
- Deleting any given node
- Deleting the last node
Case 2 - more than one node
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
111
AppMillers
www.appmillers.com
Singly Linked list Deletion
- Deleting the first node
- Deleting any given node
- Deleting the last node
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
333
AppMillers
www.appmillers.com
Singly Linked list Deletion
- Deleting the first node
- Deleting any given node
- Deleting the last node
Case 1 - one node
Head 001 1 null
001
Tail 001
null
null
AppMillers
www.appmillers.com
Singly Linked list Deletion
- Deleting the first node
- Deleting any given node
- Deleting the last node
Case 2 - more than one node
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
null
222
AppMillers
www.appmillers.com
Singly Linked list Deletion Algorithm
Location head=None?
Terminate
- head = null
- tail = null
Location = first
- Location = last Find node before last node
(loop)
- beforeLast.next = null
- tail = beforeLast
- find location (loop)
- current.next = nextNode.next
Yes
No
Yes
No
Yes
No
- head = first.next
- head = null
- tail = null
Delete entire Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
001 111 333
Tail 333 null
null
222
Time and Space Complexity of Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
001 111 333
Tail 333
222
Singly Linked List Time complexity Space complexity
Creation O(1) O(1)
Insertion O(n) O(1)
Searching O(n) O(1)
Traversing O(n) O(1)
Deletion of a node O(n) O(1)
Deletion of linked list O(1) O(1)
Circular Singly
Linked List
www.appmillers.com
Circular Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 001
001 111 222 333
Tail 333
Circular Singly Linked List
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
Singly Linked List
Create - Circular Singly Linked List
www.appmillers.com
Head 1
001
Tail
Start nodeValue
Terminate
- Create Blank Node
- node.value=nodeValue - node.next=node
- head=node
- tail=node
001 001
001
Insertion - Circular Singly Linked List
www.appmillers.com
- Insert at the beginning of linked list
- Insert at the specified location of linked list
- Insert at the end of linked list
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
Insertion - Circular Singly Linked List
www.appmillers.com
- Insert at the beginning of linked list
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
6
444
001
444
newNode
444
Insertion - Circular Singly Linked List
www.appmillers.com
- Insert at the specified location of linked list
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
6
444
newNode
444
222
Insertion - Circular Singly Linked List
www.appmillers.com
- Insert at the end of linked list
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
7
555
newNode
555
555
001
Insertion Algorithm - Circular Singly Linked List
www.appmillers.com
Check
Linked?
Terminate
- create newNode
- assign value
- newNode.next = head
- head = newNode
- tail.next = newNode
location = first ?
location = last ?
- newNode.next = tail.next
- tail.next = newNode
- tail = newNode
- find location (loop)
- newNode.next = currentNode.next
- currentNode.next = newNode
Yes
No
Yes
No
Yes
No
nodeValue
location
Traversal - Circular Singly Linked List
www.appmillers.com
Start Check Head?
Terminate
No
Yes
print(currentNode.value)
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
print(node1.value) 1
print(node2.value) 2
print(node3.value) 3
print(node4.value) 4
Searching - Circular Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
nodeValue Check Head?
Terminate
No
Yes
If currentNode=node
No
Yes
Deletion - Circular Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 3 333 4 001
001 111 222 333
Tail 333
node1 node2 node3 node4
- Deleting the first node
- Deleting any given node
- Deleting the last node
Deletion - Circular Singly Linked List
www.appmillers.com
Head 001 1 001
001
Tail 001
Case 1 - one node
null
null
null
Deleting the first node
Deletion - Circular Singly Linked List
www.appmillers.com
Case 2 - more than one node
Deleting the first node
Head 001 1 111 2 222 4 333 5 001
001 111 222 333
Tail 333
111 111
Deletion - Circular Singly Linked List
www.appmillers.com
Deleting any given node
Head 001 1 111 2 222 4 333 5 001
001 111 222 333
Tail 333
333
node1 node2 node3 node4
Deletion - Circular Singly Linked List
www.appmillers.com
Deleting the last node
Case 1 - one node
Head 001 1 001
001
Tail 001
null
null
null
Deletion - Circular Singly Linked List
www.appmillers.com
Deleting the last node
Case 2 - more than one node
Head 001 1 111 2 222 4 333 5 001
001 111 222 333
Tail 333
001
222
node1 node2 node3 node4
Deletion Algorithm - Circular Singly Linked List
www.appmillers.com
Location head=Null?
Terminate
- head = Null
- tail = Null
- first.next = Null
Location = first
Location = last - Find node before last node
(loop)
- Tail = curNode
- curNode.next = head
- find location (loop)
- current.next = nextNode.next
Yes
No
Yes
No
Yes
No
- head = first.next
- tail.next = head
- head = Null
- tail = Null
- first.next = Null
Delete Entire Circular Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 001
001 111 333
Tail 333 null
null
222
null
Time and Space Complexity of Circular Singly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 001
001 111 333
Tail 333
222
Circular Singly Linked List Time complexity Space complexity
Creation O(1) O(1)
Insertion O(n) O(1)
Searching O(n) O(1)
Traversing O(n) O(1)
Deletion of a node O(n) O(1)
Deletion of CSLL O(1) O(1)
Doubly Linked List
www.appmillers.com
Doubly Linked List
www.appmillers.com
Head 001 1 111 2 222 4 333 5 null
001 111 222 333
Tail 333
Singly Linked List
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Doubly Linked List
Create - Doubly Linked List
www.appmillers.com
Head
111
Tail
Start nodeValue
Terminate
- Create Blank Node
- node.value=nodeValue
- node.next=Null
- node.prev=Null
- head=node
- tail=node
111
111
null 5 null
Insertion - Doubly Linked List
www.appmillers.com
- Insert at the beginning of linked list
- Insert at the specified location of linked list
- Insert at the end of linked list
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Insertion - Doubly Linked List
www.appmillers.com
- Insert at the beginning of linked list
null 10
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
newNode
001
002
002 002
Insertion - Doubly Linked List
www.appmillers.com
- Insert at the specified location of linked list
111 20
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
newNode
222
555
555 555
Insertion - Doubly Linked List
www.appmillers.com
- Insert at the end of linked list
333 20
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
newNode
null
444
444
444
Insertion Algorithm - Doubly Linked List
www.appmillers.com
check Head?
Terminate
- create newNode
- assign value
- newNode.prev = null
- newNode.next = head
- head.prev = newNode
- head = newNode
location =
first ?
location =
last ?
- newNode.next = null
- newNode.prev = tail
- tail.next = newNode
- tail = newNode
- find location-1 (loop)
- newNode.next = currentNode.next
- newNode.prev = currentNode
- newNode.next.prev = newNode
- currentNode.next = newNode
Yes
No
Yes
No
Yes
No
nodeValue
location
Traversal - Doubly Linked List
www.appmillers.com
Start Check Head?
Terminate
No
Yes Loop head to tail
print(currentNode.value)
print(node1.value) 1
print(node2.value) 2
print(node3.value) 3
print(node4.value) 4
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Reverse Traversal - Doubly Linked List
www.appmillers.com
Start Check Head?
Terminate
No
Yes Loop tail to head
print(currentNode.value)
print(node4.value) 4
print(node3.value) 3
print(node2.value) 2
print(node1.value) 1
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Searching- Doubly Linked List
www.appmillers.com
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Start Check Head?
nodeValue
Terminate
No
Yes If nodeValue =
currentNode
Yes
No
Deletion - Doubly Linked List
www.appmillers.com
- Deleting the first node
- Deleting any given node
- Deleting the last node
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Deletion - Doubly Linked List
www.appmillers.com
Case 1 - one node
Deleting the first node
Head 001 null 1 null
001
Tail 001
node1
null
null
Deletion - Doubly Linked List
www.appmillers.com
Case 2 - more than one node
Deleting the first node
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
111 null
Deletion - Doubly Linked List
www.appmillers.com
Deleting any given node
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
333 111
Deletion - Doubly Linked List
www.appmillers.com
Deleting the last node
Case 1 - one node
Head 001 null 1 null
001
Tail 001
node1
null
null
Deletion - Doubly Linked List
www.appmillers.com
Deleting the last node
Case 2 - more than one node
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
null
222
Deletion Algorithm - Doubly Linked List
www.appmillers.com
Location head=Null?
Terminate
- head = null
- tail = null
Location = first
Location = last
- tail = tail.prev
- tail.next = null
- find location-1 (loop)
- curNode.next = curNode.next.next
- curNode.next.prev = curNode
Yes
No
Yes
No
Yes
No
- head = head.next
- head.prev = null
- head = null
- tail = null
Delete Entire Doubly Linked List
www.appmillers.com
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
node1 node2 node3 node4
null null null null
null
Time and Space Complexity of Doubly Linked List
www.appmillers.com
Doubly Linked List Time complexity Space complexity
Creation O(1) O(1)
Insertion O(n) O(1)
Searching O(n) O(1)
Traversing (forward ,backward) O(n) O(1)
Deletion of a node O(n) O(1)
Deletion of DLL O(n) O(1)
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 null
Circular Doubly
Linked List
www.appmillers.com
Circular Doubly Linked List
www.appmillers.com
Head 001 null 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 null
Doubly Linked List
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
Circular Doubly linked list
Create - Circular Doubly Linked List
www.appmillers.com
Head
001
Tail
Start nodeValue
Terminate
- Create Blank Node
- node.value=nodeValue
- head=node
- tail=node
- node.next=node
- node.prev=node
001
001
001 11 001
Insertion - Circular Doubly Linked List
www.appmillers.com
- Insert at the beginning of linked list
- Insert at the specified location of linked list
- Insert at the end of linked list
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
Insertion - Circular Doubly Linked List
www.appmillers.com
- Insert at the beginning of linked list
333 6
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
newNode
001
444
444 444 444
Insertion - Circular Doubly Linked List
www.appmillers.com
- Insert at the specified location of linked list
111 20
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
newNode
222
555
555 555
Insertion - Circular Doubly Linked List
www.appmillers.com
- Insert at the end of linked list
333 20
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
newNode
001
444
444
444
444
Insertion Algorithm - Circular Doubly Linked List
www.appmillers.com
check Head?
Terminate
- create newNode
- assign value
- newNode.prev = tail
- newNode.next = head
- head.prev = newNode
- head = newNode
- tail.next = newNode
location = first ?
location = last ?
- newNode.next = head
- newNode.prev = tail
- head.prev = newNode
- tail.next = newNode
- tail = newNode
- find location-1 (loop)
- newNode.next = currentNode.next
- newNode.prev = currentNode
- newNode.next.prev = newNode
- currentNode.next = newNode
Yes
No
Yes
No
Yes
No
nodeValue
location
Start Check Head?
Terminate
No
Yes Loop head to tail
print(currentNode.value)
If currentNode= tail
No
Yes
Traversal - Circular Doubly Linked List
print(node1.value) 1
print(node2.value) 2
print(node3.value) 3
print(node4.value) 4
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 001
www.appmillers.com
Start Check Head?
Terminate
No
Yes Loop tail to head
print(currentNode.value
If currentNode = head
No
Yes
Reverse Traversal - Circular Doubly Linked List
www.appmillers.com
print(node4.value) 4
print(node3.value) 3
print(node2.value) 2
print(node1.value) 1
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 001
Searching- Circular Doubly Linked List
www.appmillers.com
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 001
Start Check Head?
nodeValue
Terminate
No
Yes If
nodeValue=currentNode or if
currentNode = tail
Yes
No
Deletion - Circular Doubly Linked List
www.appmillers.com
- Deleting the first node
- Deleting any given node
- Deleting the last node
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 001
Deletion - Circular Doubly Linked List
www.appmillers.com
Case 1 - one node
Deleting the first node
Head 001 001 1 001
001
Tail 001
node1
null
null null null
Deletion - Circular Doubly Linked List
www.appmillers.com
Case 2 - more than one node
Deleting the first node
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
111 333 111
Deletion - Circular Doubly Linked List
www.appmillers.com
Deleting any given node
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
333 111
Deletion - Circular Doubly Linked List
www.appmillers.com
Deleting the last node
Case 1 - one node
Head 001 001 1 001
001
Tail 001
node1
null
null null null
Deletion - Circular Doubly Linked List
www.appmillers.com
Deleting the last node
Case 2 - more than one node
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
001
222
222
Deletion Algorithm - Circular Doubly Linked List
www.appmillers.com
Location head=null?
Terminate
- head.prev = null
- head.next = null
- head = null
- tail = null
Location = first
Location = last - tail = tail.prev
- tail.next = head
- head.prev = tail
- find location-1 (loop)
- curNode.next = curNode.next.next
- curNode.next.prev = curNode
Yes
No
Yes
No
Yes
No
- head = head.next
- head.prev = tail
- tail.next = head
- head.prev = null
- head.next = null
- head = null
- tail = null
Delete Entire Circular Doubly Linked List
www.appmillers.com
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 4 333 222 5 001
node1 node2 node3 node4
null null null null
null
null null
Time and Space Complexity of Circular Doubly Linked List
www.appmillers.com
Circular Doubly Linked List Time complexity Space complexity
Creation O(1) O(1)
Insertion O(n) O(1)
Searching O(n) O(1)
Traversing (forward ,backward) O(n) O(1)
Deletion of a node O(n) O(1)
Deletion of CDLL O(n) O(1)
Head 001 333 1 111
001 111 222 333
Tail 333
001 2 222 111 3 333 222 4 001
Time Complexity of Array vs Linked List
www.appmillers.com
Array Linked List
Creation O(1) O(1)
Insertion at first position O(1) O(1)
Insertion at last position O(1) O(1)
Insertion at nth position O(1) O(n)
Searching in Unsorted data O(n) O(n)
Searching in Sorted data O(logn) O(n)
Traversing O(n) O(n)
Deletion at first position O(1) O(1)
Deletion at last position O(1) O(n)/O(1)
Deletion at nth position O(1) O(n)
Deletion of array/linked list O(1) O(n)/O(1)
Access nth element O(1) O(n)
Linked List Interview
Questions
Remove Duplicates
Write a method to remove duplicates from an unsorted linked list.
Head 001 1 111
001 111 222 333
Tail 333
2 222 1 333 3 null
node1 node2 node3 node4
currentNode = node1
hashSet = {1}
while currentNode.next is not Null
If next node’s value is in hashSet
Delete next node
Otherwise add it to hashSet
{1,2} {1,2,3}
333
www.appmillers.com
Return Nth to Last
www.appmillers.com
Implement and algorithm to find the nth to last element of a singly linked list.
Head 001 1 111
001 111 222 333
Tail 444
2 222 0 333 3 444
node1 node2 node3 node4
pointer1 = node1
444
5 null
node5
pointer2 = node2
P1 P2
N = 2 Node4
= node2
= node3
= node4
= node3
= node4
= node5
Partition
www.appmillers.com
Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater
than or equal to x.
Head 001 11 111
001 111 222 333
Tail 444
3 222 9 333 10 444
node1 node2 node3 node4
currentNode = node1
Tail = node1
currentNode.next = null
444
15 null
node5
x = 10
11 null
001
node1
Tail 001
Head 001
111
3 null
node2
Partition
www.appmillers.com
Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater
than or equal to x.
Head 001 11 111
001 111 222 333
Tail 444
3 222 9 333 10 444
node1 node2 node3 node4
444
15 null
node5
currentNode = node1
Tail = node1
currentNode.next = null
x = 10
222
9 null
node3
3 001
111
node2
Tail 001
Head 001 11 null
001
node1
Partition
www.appmillers.com
Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater
than or equal to x.
Head 001 11 111
001 111 222 333
Tail 444
3 222 9 333 10 444
node1 node2 node3 node4
444
15 null
node5
currentNode = node1
Tail = node1
currentNode.next = null
x = 10
333
10 null
node4
9 111
222
node2
Tail 001
Head 001 11 null
001
node1
3 001
111
node2
Partition
www.appmillers.com
Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater
than or equal to x.
Head 001 11 111
001 111 222 333
Tail 444
3 222 9 333 10 444
node1 node2 node3 node4
444
15 null
node5
currentNode = node1
Tail = node1
currentNode.next = null
x = 10
444
15 null
node5
9 111
222
node2
Tail 001
Head 001 11 333
001
node1
3 001
111
node2
10 null
333
node4
Partition
www.appmillers.com
Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater
than or equal to x.
Head 001 11 111
001 111 222 333
Tail 444
3 222 9 333 10 444
node1 node2 node3 node4
444
15 null
node5
currentNode = node1
Tail = node1
currentNode.next = null
x = 10
444
15 null
node5
9 111
222
node2
Tail 001
Head 001 11 333
001
node1
3 001
111
node2
10 444
333
node4
Sum Lists
www.appmillers.com
You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored
in reverse order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and
returns the sum as a linked list.
list1 = 7 -> 1 -> 6 617
list2 = 5 -> 9 -> 2 295 617 + 295 = 912 sumList = 2 -> 1 -> 9
617
+ 295
7 + 5 = 12
2
1+9+1 = 11
91 6+2+1 = 9
7 1 6
5 9 2
2 1 9
Intersection
www.appmillers.com
Given two (singly) linked lists, determine if the two lists intersect. Return the intersecting node. Note that the
intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact
same node (by reference) as the jth node of the second linked list, then they are intersecting.
3 1 5 9
2 4 6
7 2 1
Intersecting linked lists
3 1 5 9
2 4 6
7 2 1
7 2 1
Non - intersecting linked lists
Intersection
www.appmillers.com
Given two (singly) linked lists, determine if the two lists intersect. Return the intersecting node. Note that the
intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact
same node (by reference) as the jth node of the second linked list, then they are intersecting.
3 1 5 9
2 4 6
7 2 1
Intersecting linked lists
listA
listB
len(listA) = 7
len(listB) = 6 7 - 6 = 1
Stack
What is a Stack?
 Stack is a data structure that stores items in a Last-In/First-Out manner.
www.appmillers.com
What is a Stack?
 Stack is a data structure that stores items in a Last-In/First-Out manner.
www.appmillers.com
LIFO method
What is a Stack?
 Stack is a data structure that stores items in a Last-In/First-Out manner.
www.appmillers.com
10
20
30
40
Why do we need Stack?
www.appmillers.com
udemy.com gmail.com linkedin.com appmillers.com
udemy.com
gmail.com
linkedin.com
appmillers.com
Stack
Stack Operations
www.appmillers.com
- Create Stack
- Push
- Pop
- Peek
- isEmpty
- isFull
- deleteStack
customStack()
Push Method
www.appmillers.com
customStack = [ ]
customStack.push(1)
[1]
Push Method
www.appmillers.com
customStack =
customStack.push(1)
1
customStack.push(2)
Push Method
www.appmillers.com
customStack =
1
2
[1,2]
customStack.push(2) customStack.push(3)
Push Method
www.appmillers.com
customStack =
1
2
3
[1,2,3]
customStack.push(3) customStack.push(4)
Push Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.push(4)
Pop Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.pop() 4
[1,2,3]
Pop Method
www.appmillers.com
customStack =
1
2
3
[1,2,3]
customStack.pop() 3
[1,2]
Pop Method
www.appmillers.com
customStack =
1
2
[1,2]
customStack.pop() 2
[1]
Pop Method
www.appmillers.com
customStack =
1
[1]
customStack.pop() 1
[]
Pop Method
www.appmillers.com
customStack.pop()
customStack = []
The stack is Empty
Peek Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.peek() 4
isEmpty Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.isEmpty() False
isFull Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.isFull() False
Delete Method
www.appmillers.com
customStack =
1
2
3
4
[1,2,3,4]
customStack.delete()
Stack Creation - Array vs Linked List
www.appmillers.com
Stack using Array
- Easy to implement
- Fixed size
Stack using Linked List
- Variable size
- Implementation is not easy
Time and Space Complexity of Stack using Array
www.appmillers.com
Stack Time complexity Space complexity
Create Stack O(1) O(n)
Push O(1) O(1)
Pop O(1) O(1)
Peek O(1) O(1)
isEmpty O(1) O(1)
Delete Entire Stack O(1) O(1)
Stack using Linked List
www.appmillers.com
Create a Stack
Create an object of Linked List class
Head null
Stack using Linked List
www.appmillers.com
Push() Method
Head null null
111
111 1
null
222
111
1
2
222
2
Stack using Linked List
www.appmillers.com
Push() Method
Head 222 111
222
2
null
333
222
1
3
333
2
1 null
111
3
Stack using Linked List
www.appmillers.com
Pop() Method
Head 333 1 null
111
2 111
222
1
2
3 222
333
222 3
Stack using Linked List
www.appmillers.com
Pop() Method
Head 222 1 null
111
1
2 111
222
111
2
Stack using Linked List
www.appmillers.com
Peek() Method
Head 333 1 null
111
2 111
222
1
2
3 222
333
3
peek()
 return head.value
isEmpty()
 If head==null {
true
}
Stack using Linked List
www.appmillers.com
isEmpty() Method
Head 333 1 null
111
2 111
222
1
2
3 222
333
3
Stack using Linked List
www.appmillers.com
delete() Method
Head 333 1 null
111
2 111
222
1
2
3 222
333
3
delete()
 head = null
Time and Space Complexity of Stack using Linked List
www.appmillers.com
Stack Time complexity Space complexity
Create Stack O(1) O(1)
Push O(1) O(1)
Pop O(1) O(1)
Peek O(1) O(1)
isEmpty O(1) O(1)
Delete Entire Stack O(1) O(1)
When to Use/Avoid Stack
www.appmillers.com
Use:
- LIFO functionality
- The chance of data corruption is minimum
Avoid:
- Random access is not possible
1
2
3
4
Queue
What is a Queue?
 Queue is a data structure that stores items in a First-In/First-Out manner.
www.appmillers.com
A new addition to this queue happens at the end of the queue.
First person in the queue will be served first
FIFO method - First in First Out
What is a Queue?
 Queue is a data structure that stores items in a First-In/First-Out manner.
www.appmillers.com
50 40 30 20 10
End Front
Why do we need Queue?
www.appmillers.com
-Utilize first coming data first , while others wait for their turn.
-FIFO method - First In First Out
Why do we need Queue?
www.appmillers.com
Point sale system of a restaurant
Why do we need Queue?
www.appmillers.com
Printer queue
Why do we need Queue?
www.appmillers.com
Call center phone systems
Queue Operations
www.appmillers.com
- Create Queue
- Enqueue
- Dequeue
- Peek
- isEmpty
- isFull
- deleteQueue
Queue Operations
www.appmillers.com
Implementation
1. Array
 - Linear Queue
 - Circular Queue
2. Linked List
1 2 3
Head 111 3 null
333
2 333
222
1 222
111
Tail 333
Linear Queue using Array
www.appmillers.com
Create a Queue
newQueue = Queue(6)
beginnigOfQueue = -1
topOfQueue = -1
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
enQueue Method
newQueue.enqueue(1)
1
beginnigOfQueue = 0
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
enQueue Method
newQueue.enqueue(2)
1
beginnigOfQueue = 0
topOfQueue = 1
2
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
enQueue Method
newQueue.enqueue(3)
1
beginnigOfQueue = 0
topOfQueue = 2
2 3
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
deQueue Method
newQueue.dequeue()
1
beginnigOfQueue = 0
topOfQueue = 2
2 3
1
beginnigOfQueue = 1
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
deQueue Method
newQueue.dequeue()
beginnigOfQueue = 1
topOfQueue = 2
2 3
2
beginnigOfQueue = 2
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
peek Method
newQueue.peek()
1
beginnigOfQueue = 0
topOfQueue = 2
2 3
1
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
isEmpty Method
newQueue.isEmpty()
1
beginnigOfQueue = 0
topOfQueue = 2
2 3
False
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
isFull Method
newQueue.isFull()
1
beginnigOfQueue = 0
topOfQueue = 2
2 3
False
[0] [1] [2] [3] [4] [5]
Linear Queue using Array
www.appmillers.com
delete Method
newQueue.delete()
1 2 3
[0] [1] [2] [3] [4] [5]
Time and Space Complexity of Linear Queue using Array
www.appmillers.com
Linear Queue - Array Time complexity Space complexity
Create Queue O(1) O(N)
enQueue O(1) O(1)
deQueue O(1) O(1)
Peek O(1) O(1)
isEmpty O(1) O(1)
isFull O(1) O(1)
Delete Entire Queue O(1) O(1)
Why do we need Circular Queue?
www.appmillers.com
10 20 30
deQueue method causes blank cells.
10 20 30 40 50 60
topOfQueue = 2
[0] [1] [2] [3] [4] [5]
+1 = 3 +1 = 4 +1 = 5
Circular Queue using Array
www.appmillers.com
Create a Queue
newQueue = Queue(6)
beginnigOfQueue = -1
topOfQueue = -1
[0] [1] [2] [3] [4] [5]
Circular Queue using Array
www.appmillers.com
enQueue Method
newQueue.enQueue(5)
beginnigOfQueue = 0
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
5
B T
Circular Queue using Array
www.appmillers.com
enQueue Method
newQueue.enQueue(6)
beginnigOfQueue = 0
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
5
B T
6
topOfQueue = 1
Circular Queue using Array
www.appmillers.com
enQueue Method
newQueue.enQueue(7)
beginnigOfQueue = 0
topOfQueue = 1
[0] [1] [2] [3] [4] [5]
5
B T
6
topOfQueue = 2
7
Circular Queue using Array
www.appmillers.com
deQueue Method
8 9 10
newQueue.deQueue()
beginnigOfQueue = 0
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
5
B T
6 7
5
beginnigOfQueue = 1
Circular Queue using Array
www.appmillers.com
deQueue Method
8 9 10
newQueue.deQueue()
beginnigOfQueue = 1
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
5
B T
6 7
6
beginnigOfQueue = 2
Circular Queue using Array
www.appmillers.com
deQueue Method
8 9 10
newQueue.enQueue(1)
beginnigOfQueue = 2
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
5
B T
1 6 7
topOfQueue = 0
Circular Queue using Array
www.appmillers.com
Peek Method
8 9 10
newQueue.peek()
beginnigOfQueue = 1
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
B T
6 7
6
Circular Queue using Array
www.appmillers.com
isFull Method
8 9 10
newQueue.isFull()
beginnigOfQueue = 1
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
B T
6 7
False
Circular Queue using Array
www.appmillers.com
isFull Method
8 9 10
newQueue.isFull()
beginnigOfQueue = 0
topOfQueue = 5
[0] [1] [2] [3] [4] [5]
B T
6 7
True
5
Circular Queue using Array
www.appmillers.com
isFull Method
8 9 10
newQueue.isFull()
beginnigOfQueue = 1
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
T B
6 7
True
5
Circular Queue using Array
www.appmillers.com
isEmpty Method
8 9 10
newQueue.isEmpty()
beginnigOfQueue = 1
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
T B
6 7
False
5
Circular Queue using Array
www.appmillers.com
Delete Method
8 9 10
newQueue.delete()
beginnigOfQueue = 1
topOfQueue = 0
[0] [1] [2] [3] [4] [5]
T B
5 6 7
Time and Space Complexity of Circular Queue using Array
www.appmillers.com
Circular Queue - Array Time complexity Space complexity
Create Queue O(1) O(N)
enQueue O(1) O(1)
deQueue O(1) O(1)
Peek O(1) O(1)
isEmpty O(1) O(1)
isFull O(1) O(1)
Delete Entire Queue O(1) O(1)
Queue using Linked List
www.appmillers.com
Create a Queue
Create an object of Linked List class
Head null
Tail null
Queue using Linked List
www.appmillers.com
enQueue() Method
Head null null
111
111 1 null
222
1
222 2
2
Tail null 222 111
Queue using Linked List
www.appmillers.com
enQueue() Method
Head null null
111
111 1 null
222
1
222 2
2
Tail null 222 111
null
333
333 3
333
3
Queue using Linked List
www.appmillers.com
deQueue() Method
Head 111 3 null
333
2 333
222
1 222
111
222
Tail 333
3 2 1
Queue using Linked List
www.appmillers.com
deQueue() Method
Head 222 3 null
333
2 333
222
333
Tail 333
3 2
Queue using Linked List
www.appmillers.com
peek() Method
Head 111 3 null
333
2 333
222
1 222
111
Tail 333
3 2 1
peek()
 return head.value
Queue using Linked List
www.appmillers.com
isEmpty() Method
Head 111 3 null
333
2 333
222
1 222
111
Tail 333
3 2 1
isEmpty()
 If head is Null:
True
Queue using Linked List
www.appmillers.com
delete() Method
Head 111 3 null
333
2 333
222
1 222
111
Tail 333
3 2 1
null
null
delete()
 head = Null
 tail = Null
Time and Space Complexity of Queue using Linked List
www.appmillers.com
Queue - Linked List Time complexity Space complexity
Create Queue O(1) O(1)
enQueue O(1) O(1)
deQueue O(1) O(1)
Peek O(1) O(1)
isEmpty O(1) O(1)
Delete Entire Queue O(1) O(1)
Queue - Array vs Linked List
www.appmillers.com
Array Linked List
Time complexity Space complexity Time complexity Space complexity
Create Queue O(1) O(n) O(1) O(1)
Enqueue O(1) O(1) O(1) O(1)
Dequeue O(1) O(1) O(1) O(1)
Peek O(1) O(1) O(1) O(1)
isEmpty O(1) O(1) O(1) O(1)
isFull O(1) O(1) - -
Delete Entire Queue O(1) O(1) O(1) O(1)
Space efficient? NO Yes
When to Use/Avoid Queue?
www.appmillers.com
Use:
- FIFO functionality
- The chance of data corruption is minimum
Avoid:
- Random access is not possible
3 2 1
Stack and Queue
Interview Questions
Stack and Queue Interview Questions
www.appmillers.com
Three in One
Describe how you could use a single Array to implement three stacks.
www.appmillers.com
For Stack 1 — [0], [1], [2]
[0] [1] [2] [3] [4] [5] [6] [7] [8]
For Stack 2 — [3], [4], [5]
For Stack 3 — [6], [7], [8]
[0, n/3)
[n/3, 2n/3)
[2n/3, n)
Stack Min
How would you design a stack which, in addition to push and pop, has a function min which returns the
minimum element? Push, pop and min should all operate in O(1).
www.appmillers.com
5
6
3
7
push(5) min() 5
push(6) min() 5
push(3) min() 3
push(7) min() 3
pop() min() 3
pop() min() 5
Stack of Plates
 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a
new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this.
SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity,
SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop( ) should return the same
values as it would if there were just a single stack).
www.appmillers.com
Follow Up:
Implement a function popAt (int index) which performs a pop operation on a specific sub - stack.
Stack of Plates
 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a
new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this.
SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity,
SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop( ) should return the same
values as it would if there were just a single stack).
www.appmillers.com
pop( )
Follow Up:
Implement a function popAt (int index) which performs a pop operation on a specific sub - stack.
Queue via Stacks
Implement Queue class which implements a queue using two stacks.
www.appmillers.com
5
6
3
7
Stack1 Stack2
Dequeue() Enqueue()
8
Animal Shelter
An animal shelter, which holds only dogs and cats, operates on a strictly "first in, first out" basis. People must adopt either
the "oldest" (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat
(and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data
structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat.
www.appmillers.com
� � � � � � �
Newest Oldest
First In First Out
Enqueue(Dog)
�
Enqueue(Cat)
Animal Shelter
An animal shelter, which holds only dogs and cats, operates on a strictly "first in, first out" basis. People must adopt either
the "oldest" (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat
(and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data
structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat.
www.appmillers.com
� � � � � � �
Newest Oldest
First In First Out
DequeueAny()
�
DequeueDog()
DequeueCat()
Tree / Binary Tree
What is a Tree?
www.appmillers.com
A tree is a nonlinear data structure with hierarchical relationships between its elements without having any
cycle, it is basically reversed from a real life tree.
Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
Green Black Americano Latte Cappuccino Cola Fanta Soda Wine Beer
What is a Tree?
www.appmillers.com
A tree is a nonlinear data structure with hierarchical relationships between its elements without having any
cycle, it is basically reversed from a real life tree.
Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
Green Black Americano Latte Cappuccino Cola Fanta Soda Wine Beer
Properties:
- Represent hierarchical data
- Each node has two components : data and a link to its sub category
- Base category and sub categories under it
What is a Tree?
www.appmillers.com
A tree is a nonlinear data structure with hierarchical relationships between its elements without having any
cycle, it is basically reversed from a real life tree.
N1
N6
N2 N3
N4 N5
N7 N8
Tree Properties:
- Represent hierarchical data
- Each node has two components : data and a link to its sub category
- Base category and sub categories under it
Why Tree?
www.appmillers.com
- Quicker and Easier access to the data
- Store hierarchical data, like folder structure, organization structure, XML/HTML data.
The file system on a computer
Why Tree?
www.appmillers.com
- Quicker and Easier access to the data
- Store hierarchical data, like folder structure, organization structure, XML/HTML data.
- There are many different types of data structures which performs better in various situations
- Binary Search Tree, AVL, Red Black Tree, Trie
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
root
Edge : a link between parent and child
edge
Leaf : a node which does not have children
leaf
Sibling : children of same parent
sibling
Ancestor : parent, grandparent, great grandparent of a node
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
Edge : a link between parent and child
Leaf : a node which does not have children
Sibling : children of same parent
Ancestor : parent, grandparent, great grandparent of a node
ancestors of N7
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
Edge : a link between parent and child
Leaf : a node which does not have children
Sibling : children of same parent
Ancestor : parent, grandparent, great grandparent of a node
Depth of node : a length of the path from root to node
Depth of N4 = 2
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
Edge : a link between parent and child
Leaf : a node which does not have children
Sibling : children of same parent
Ancestor : parent, grandparent, great grandparent of a node
Depth of node : a length of the path from root to node
Heigh of N3 = 1
Height of node : a length of the path from the node to the deepest node
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
Edge : a link between parent and child
Leaf : a node which does not have children
Sibling : children of same parent
Ancestor : parent, grandparent, great grandparent of a node
Depth of node : a length of the path from root to node
Height of node : a length of the path from the node to the deepest node
Depth of tree = 0
Depth of tree : depth of root node
Tree Terminology
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
Root : top node without parent
Edge : a link between parent and child
Leaf : a node which does not have children
Sibling : children of same parent
Ancestor : parent, grandparent, great grandparent of a node
Depth of node : a length of the path from root to node
Height of node : a length of the path from the node to the deepest node
Depth of tree : depth of root node
Height of tree = 3
Height of tree : height of root node
Binary Tree
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
- Binary trees are the data structures in which each node has at most two children, often referred to as
the left and right children
- Binary tree is a family of data structure (BST, Heap tree, AVL, red black trees, Syntax tree)
Why Binary Tree?
www.appmillers.com
N1
N6
N2 N3
N4 N5
N7 N8
- Binary trees are a prerequisite for mode advanced trees like BST, AVL, Red Black Trees
- Huffman coding problem , heap priority problem and expression parsing problems can be solved
efficiently using binary trees,
Types of Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5
N6 N7
Full Binary Tree
Types of Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
Perfect Binary Tree
Types of Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Complete Binary Tree
Types of Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5 N7
Balanced Binary Tree
Binary Tree
www.appmillers.com
- Linked List
- Array
Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
Binary Tree
www.appmillers.com
Linked List
222 Drinks 333
111
444 Hot 555
222
666 Cold 777
333
null Cola null
666
null Fanta null
777
null Tea null
444
null Coffee null
555
Binary Tree
www.appmillers.com
Array Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
Binary Tree
www.appmillers.com
Array Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
Drinks Hot Cold
x = 1 , cell[2x1=2]
x = 1 , cell[2x1+1=3]
Binary Tree
www.appmillers.com
Array Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
Drinks Hot Cold
x = 2 , cell[2x2=4]
x = 2, cell[2x2+1=5]
Tea Coffee
Binary Tree
www.appmillers.com
Array Drinks
Hot Cold
Tea Coffee Non alcoholic Alcoholic
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
Drinks Hot Cold
x = 3 , cell[2x3=6]
x = 3, cell[2x3+1=7]
Tea Coffee Non alcoholic Alcoholic
Binary Tree using Linked List
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
- Creation of Tree
- Insertion of a node
- Deletion of a node
- Search for a value
- Traverse all nodes
- Deletion of tree
newTree = Tree()
Binary Tree - Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Depth first search
- Preorder traversal
- Inorder traversal
- Post order traversal
Breadth first search
- Level order traversal
Binary Tree - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
N1 N2
Binary Tree - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
N1 N2 N4 N8 N9
Binary Tree - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
N1 N2 N4 N8 N9 N5 N3 N6 N7
Binary Tree - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
N1 N2 N4 N8 N9 N5 N3 N6 N7
Binary Tree - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
N1 N2 N4 N8 N9 N5 N3 N6 N7
Binary Tree - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
N8 N4
Binary Tree - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
N8 N4 N9 N2 N5
Binary Tree - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
N9 N4 N9 N2 N5 N1 N6 N3 N7
Binary Tree - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
N9 N4 N9 N2 N5 N1 N6 N3 N7
Binary Tree - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
N8 N4 N9 N2 N5 N1 N6 N3 N7
Binary Tree - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
N8 N9
Binary Tree - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
N8 N9 N4 N5 N2
Binary Tree - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
N8 N9 N4 N5 N2 N6 N7 N3 N1
Binary Tree - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
N8 N9 N4 N5 N2 N6 N7 N3 N1
Binary Tree - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
N8 N9 N4 N5 N2 N6 N7 N3 N1
Binary Tree - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level 1
Level 2
Level 3
Level 4
Binary Tree - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level 1
Level 2
Level 3
Level 4
N1 N2 N3 N4 N5
Binary Tree - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level 1
Level 2
Level 3
Level 4
N1 N2 N3 N4 N5 N6 N7 N8 N9
Binary Tree - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
N1 N2 N3 N4 N5 N6 N7 N8 N9
Binary Tree - Search
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level 1
Level 2
Level 3
Level 4
N5
Level Order Traversal
Success
Binary Tree - Insert a Node
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level Order Traversal
newNode
- A root node is null
- The tree exists and we have to look for a first vacant
place
N10
Binary Tree - Delete a Node
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level Order Traversal
N3
Step 1 - Find the Node
Step 2 - Find Deepest Node
Step 3 - Set Deepest Node’s value to Current Node
Step 4 - Delete Deepest Node
N9
Binary Tree - Delete Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
rootNode = Null
Binary Tree using Array
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
- Creation of Tree
- Insertion of a node
- Deletion of a node
- Search for a value
- Traverse all nodes
- Deletion of tree
Binary Tree using Array
www.appmillers.com
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
N1
N2 N3
N4 N5 N6 N7
Binary Tree using Array
www.appmillers.com
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
N1 N2 N3
x = 1 , cell[2x1=2]
x = 1 , cell[2x1+1=3]
N1
N2 N3
N4 N5 N6 N7
Binary Tree using Array
www.appmillers.com
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
N1 N2 N3
x = 2 , cell[2x2=4]
x = 2, cell[2x2+1=5]
N4 N5
N1
N2 N3
N4 N5 N6 N7
Binary Tree using Array
www.appmillers.com
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
N1 N2 N3
x = 3 , cell[2x3=6]
x = 3, cell[2x3+1=7]
N4 N5 N6 N7
N1
N2 N3
N4 N5 N6 N7
newBT = BTclass()
Fixed size Array
lastUsedIndex
Binary Tree (Array) - Insert a Node
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9 New
N1 N2 N3 N4 N5 N6 N7 N8 N9
0 1 2 3 4 5 6 7 8 9 10 11
New
newNode
- The Binary Tree is full
- We have to look for a first vacant place
Left child = cell[2x]
indexOfParent = 10/2 = 5
Index = 10
lastUsedIndex = 9
Binary Tree (Array) - Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Depth first search
- Preorder traversal
- Inorder traversal
- Post order traversal
Breadth first search
- Level order traversal
Binary Tree (Array) - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
Binary Tree (Array) - PreOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Root Node
Left Subtree
Right Subtree
Binary Tree (Array) - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
Binary Tree (Array) - InOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Root Node
Right Subtree
Binary Tree (Array) - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
Binary Tree (Array) - Post Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Left Subtree
Right Subtree
Root Node
Binary Tree (Array) - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level 1
Level 2
Level 3
Level 4
Binary Tree - LevelOrder Traversal
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Binary Tree (Array) - Search
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
Level 1
Level 2
Level 3
N5
Level Order Traversal
5
N6 N7
0 1 2 3 4 5 6
N1 N2 N3 N4 N5
7 8
Binary Tree (Array) - Delete a Node
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
Level Order Traversal
N3
N9
deepestNode = lastUsedIndex
N1 N2 N3 N4 N5 N6 N7 N8 N9
0 1 2 3 4 5 6 7 8 9 10 11
N9
Binary Tree (Array) - Delete Binary Tree
www.appmillers.com
N1
N2 N3
N4 N5 N6 N7
N8 N9
arr = Null
Binary Tree (Array vs Linked List)
www.appmillers.com
Array Linked List
Time complexity Space complexity Time complexity Space complexity
Create Binary Tree O(1) O(n) O(1) O(1)
Insert a node to Binary Tree O(1) O(1) O(n) O(n)
Delete a node from Binary Tree O(n) O(1) O(n) O(n)
Search for a node in Binary Tree O(n) O(1) O(n) O(n)
Traverse Binary Tree O(n) O(1)/O(n) O(n) O(n)
Delete entire Binary Tree O(1) O(1) O(1) O(1)
Space efficient? No Yes
Binary Search Tree
20
10 30
5 15
What is a Binary Search Tree?
www.appmillers.com
- In the left subtree the value of a node is less than or equal to its parent node’s value.
- In the right subtree the value of a node is greater than its parent node’s value
70
50 90
30 60
20 40
80 100
What is a Binary Search Tree?
www.appmillers.com
- In the left subtree the value of a node is less than or equal to its parent node’s value.
- In the right subtree the value of a node is greater than its parent node’s value
70
50 90
30 60
20 40
80 100
Why Binary Search Tree?
www.appmillers.com
- It performs faster than Binary Tree when inserting and deleting nodes
70
50 90
30 60
20 40
80 100
Common Operations on Binary Search Tree
www.appmillers.com
70
50 90
30 60
20 40
80 100
- Creation of BST
- Insertion of a node
- Deletion of a node
- Search for a value
- Traverse all nodes
- Deletion of BST
Create Binary Search Tree
www.appmillers.com
70
50 90
30 60
20 40
80 100
newBST = BST()
Binary Search Tree - Insert a Node
www.appmillers.com
70
50 90
30 60
20 40
80 100
10
Smaller Bigger
10
Binary Search Tree - Insert a Node
www.appmillers.com
70
50 90
30 60
20 40
80 100
Smaller Bigger
95
Binary Search Tree - Insert a Node
www.appmillers.com
70
50 90
30 60
20 40
80 100
Smaller Bigger
Binary Search Tree - Traversal
www.appmillers.com
70
50 90
30 60 80 100
20 40
Depth first search
- Preorder traversal
- Inorder traversal
- Post order traversal
Breadth first search
- Level order traversal
70
50 90
30 60 80 100
20 40
Binary Search Tree - PreOrder Traversal
www.appmillers.com
Root Node
Left Subtree
Right Subtree
70
50 90
30 60 80 100
20 40
Binary Search Tree - PreOrder Traversal
www.appmillers.com
Root Node
Left Subtree
Right Subtree
70
50 90
30 60 80 100
20 40
Binary Search Tree - InOrder Traversal
www.appmillers.com
Left Subtree
Root Node
Right Subtree
70
50 90
30 60 80 100
20 40
Binary Search Tree- InOrder Traversal
www.appmillers.com
Left Subtree
Root Node
Right Subtree
70
50 90
30 60 80 100
20 40
Binary Search Tree- Post Traversal
www.appmillers.com
Left Subtree
Right Subtree
Root Node
70
50 90
30 60 80 100
20 40
Binary Search Tree - Post Traversal
www.appmillers.com
Left Subtree
Right Subtree
Root Node
Binary Search Tree - LevelOrder Traversal
www.appmillers.com
Level 1
Level 2
Level 3
Level 4
70
50 90
30 60 80 100
20 40
70
50 90
30 60 80 100
20 40
Binary Search Tree - LevelOrder Traversal
www.appmillers.com
70
50 90
30 60 80 100
20 40
Binary Search Tree - Search
www.appmillers.com
40
Success
70
50 90
30 60 80 100
20 40
Binary Search Tree - Delete a Node
www.appmillers.com
Case 1: The node to be deleted is a leaf node
Case 2: The node has one child
Case 3: The node has two children
70
50 90
30 60 80 100
20 40
Binary Search Tree - Delete a Node
www.appmillers.com
Case 1: The node to be deleted is a leaf node
70
50 90
30 60 80 100
20
Binary Search Tree - Delete a Node
www.appmillers.com
Case 2: The node has one child
70
50 90
30 60 80 100
20 40
Binary Search Tree - Delete a Node
www.appmillers.com
Case 3: The node has two children
85
80
70
50 90
30 60 80 100
20 40
Binary Search Tree - Delete
www.appmillers.com
root = null
85
Binary Search Tree - Time and Space Complexity
www.appmillers.com
Time complexity Space complexity
Create BST O(1) O(1)
Insert a node BST O(logN) O(logN)
Traverse BST O(N) O(N)
Search for a node BST O(logN) O(logN)
Delete node from BST O(logN) O(logN)
Delete Entire BST O(1) O(1)
AVL Tree
20
10 30
5 15
What is an AVL Tree?
www.appmillers.com
An AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right
subtrees cannot be more than one for all nodes.
70
50 90
30 60
20 40
80 100
What is an AVL Tree?
www.appmillers.com
An AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right
subtrees cannot be more than one for all nodes.
70
50 90
30
20 40
80 100
Height of leftSubtree = 3
Height of rightSubtree = 2
difference = 1
Height of leftSubtree = 1
Height of rightSubtree = 1
difference = 0
Height of leftSubtree = 2
Height of rightSubtree = 0
difference = 2
What is an AVL Tree?
www.appmillers.com
An AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right
subtrees cannot be more than one for all nodes.
70
50 90
30
20 40
80 100
If at any time heights of left and right subtrees differ by more than one, then rebalancing is done to restore
AVL property, this process is called rotation
70
50 90
30 60 80 100
What is an AVL Tree?
www.appmillers.com
Examples
Height of leftSubtree = 2
Height of rightSubtree = 2
difference = 0
Height of leftSubtree = 1
Height of rightSubtree = 1
difference = 0
Height of leftSubtree = 1
Height of rightSubtree = 1
difference = 0
70
50 90
30 60 80 100
20
What is an AVL Tree?
www.appmillers.com
Examples
Height of leftSubtree = 3
Height of rightSubtree = 2
difference = 1
Height of leftSubtree = 2
Height of rightSubtree = 1
difference = 1
Height of leftSubtree = 1
Height of rightSubtree = 1
difference = 0
Height of leftSubtree = 1
Height of rightSubtree = 0
difference = 1
70
50 90
30 60 80 100
20
10
What is an AVL Tree?
www.appmillers.com
Examples
Height of leftSubtree = 4
Height of rightSubtree = 2
difference = 2
What do we need AVL Tree?
www.appmillers.com
10, 20, 30, 40, 50, 60, 70
Search for 60
Time complexity is O(N)
10
20
40
30
50
60
70
What do we need AVL Tree?
www.appmillers.com
10, 20, 30, 40, 50, 60, 70
Search for 60
Time complexity is O(LogN)
10
20
40
30
50
60
70
40
20 60
10 30 50 70
Common Operations on AVL Tree
www.appmillers.com
40
20 60
10 30 50 70
- Creation of AVL trees,
- Search for a node in AVL trees
- Traverse all nodes in AVL trees
- Insert a node in AVL trees
- Delete a node from AVL trees
- Delete the entire AVL trees
Common Operations on AVL Tree
www.appmillers.com
40
20 60
10 30 50 70
newAVL = AVL()
rooNode = Null
Time complexity : O(1)
Space complexity : O(1)
70
50 90
30 60 80 100
20 40
AVL Tree - PreOrder Traversal
www.appmillers.com
Root Node
Left Subtree
Right Subtree
Time complexity : O(N)
Space complexity : O(N)
70
50 90
30 60 80 100
20 40
AVL Tree- InOrder Traversal
www.appmillers.com
Left Subtree
Root Node
Right Subtree
Time complexity : O(N)
Space complexity : O(N)
70
50 90
30 60 80 100
20 40
AVL Tree - Post Traversal
www.appmillers.com
Left Subtree
Right Subtree
Root Node
Time complexity : O(N)
Space complexity : O(N)
70
50 90
30 60 80 100
20 40
AVL Tree - LevelOrder Traversal
www.appmillers.com
Time complexity : O(N)
Space complexity : O(N)
70
50 90
30 60 80 100
20 40
AVL Tree - Search
www.appmillers.com
80
Success
Time complexity : O(LogN)
Space complexity : O(LogN)
70
50 90
30 60 80 100
20 40
AVL Tree - Search
www.appmillers.com
80
Success
Time complexity : O(LogN)
Space complexity : O(LogN)
70
50 90
30 60 80 100
20 40
AVL Tree - Insert a Node
www.appmillers.com
Case 1 : Rotation is not required
Case 2 : Rotation is required
70
50 90
30 60 80 100
20 40
AVL Tree - Insert a Node
www.appmillers.com
Case 1 : Rotation is not required 75
70
50 90
30 60 80 100
20
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
LR - left right condition
RR - right right condition
RL - right left condition
70
50 90
30 60 80 100
20
10
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
70
50 90
30 60 80 100
20
10
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
Left
Left
70
50 90
30 60 80 100
20
10
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
Right rotation
70
50 90
30 60
20
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
Right rotation - example 2
70
50 90
30 60
20
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
Right rotation - example 2
Left
Left
50
30 60
70
90
20
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LL - left left condition
Right rotation - example 2
50
30 60
70
90
20
AVL Tree - Insert a Node
www.appmillers.com
Right Rotation - example 2
30
20 60
50
70
90
AVL Tree - Insert a Node
www.appmillers.com
Algorithm of Left Left (LL) Condition
rotateRight(disbalancedNode) {
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
}
30
20
10
newRoot =
20
10
disbalancedNode = 30
newRoot =
20
10 30
Null
Time complexity : O(1)
Space complexity : O(1)
70
50 90
30 60 80 100
20
25
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LR - left right condition
70
50 90
30 60 80 100
20
25
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LR - left right condition
Left
Right
70
50 90
30 60 80 100
20
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LR - left right condition
1. Left rotation
2. Right rotation
25
70
50 90
30 60 80 100
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
LR - left right condition
1. Left rotation
2. Right rotation
20
25
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Left Right Condition
1. Left Rotation
2. Right Rotation
70
50 90
30 60
20
80 100
25
70
50 90
30 60
25
80 100
20
70
50 90
25 60
20
80 100
30
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Left Right Condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Left disbalancedNode.leftChild
Step 2 : rotate Right disbalancedNode
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Left Right Condition
Step 1 : rotate Left disbalancedNode.leftChild
Step 2 : rotate Right disbalancedNode
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
30
10
20
newRoot = 20
disbalancedNode = 10
newRoot =
20
10
disbalancedNode =
30
20
10
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Left Right Condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Left disbalancedNode.leftChild
Step 2 : rotate Right disbalancedNode
30
20
10
newRoot =
20
10
disbalancedNode = 30
newRoot =
20
10 30
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Left Right Condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Left disbalancedNode.leftChild
Step 2 : rotate Right disbalancedNode
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Time complexity : O(1)
Space complexity : O(1)
50
40 60
70
75
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition
50
40 60
70
75
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition Right
Right
50
40 60
70
75
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition
Left Rotation
50
40 65
70
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition
Left Rotation - example 2
60
75 Right
Right
50
40 65
70
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition
Left Rotation - example 2
60
75
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RR - right right condition
Left Rotation
50
40 65
75
60 70
65
50 70
40 60 75
AVL Tree - Insert a Node
www.appmillers.com
RR - right right condition
30
40
50
newRoot =
disbalancedNode = 30
- rotate Left disbalancedNode
rotateLeft(disbalancedNode)
 newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
disbalancedNode =
40
30 50
40
50
Time complexity : O(1)
Space complexity : O(1)
50
40 60
70
65
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RL - right left condition
50
40 60
70
65
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RL - right left condition Right
Left
50
40 60
70
65
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RL - right left condition
1. Right rotation
2. Left rotation
50
40 60
65
AVL Tree - Insert a Node
www.appmillers.com
Case 2 : Rotation is required
RL - right left condition
1. Right rotation
2. Left rotation
70
AVL Tree - Insert a Node
www.appmillers.com
RL - right left condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Right disbalancedNode.rightChild
Step 2 : rotate Left disbalancedNode
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
AVL Tree - Insert a Node
www.appmillers.com
RL - right left condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Right disbalancedNode.rightChild
Step 2 : rotate Left disbalancedNode
30
40
35
newRoot = 35
disbalancedNode = 40
newRoot =
35
40
disbalancedNode =
30
35
40
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
AVL Tree - Insert a Node
www.appmillers.com
RL - right left condition
Step 1 : rotate Right disbalancedNode.rightChild
Step 2 : rotate Left disbalancedNode
35
40
disbalancedNode = 30
newRoot =
35
30 40
30
35
40
newRoot =
AVL Tree - Insert a Node
www.appmillers.com
RL - right left condition
rotateRight(disbalancedNode)
newRoot = disbalancedNode.leftChild
disbalancedNode.leftChild = disbalancedNode.leftChild.rightChild
newRoot.rightChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Step 1 : rotate Right disbalancedNode.rightChild
Step 2 : rotate Left disbalancedNode
rotateLeft(disbalancedNode)
newRoot = disbalancedNode.rightChild
disbalancedNode.rightChild = disbalancedNode.rightChild.leftChild
newRoot.leftChild = disbalancedNode
update height of disbalancedNode and newRoot
return newRoot
Time complexity : O(1)
Space complexity : O(1)
AVL Tree - Insert a Node (All together)
Case 1 : Rotation is not required
Case 2 : Rotation is required
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
www.appmillers.com
30
25 35
15
20
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Left
Left
Right rotation
AVL Tree - Insert a Node (All together)
www.appmillers.com
30
20 35
5
15
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Left
Left
Right rotation
25
AVL Tree - Insert a Node (All together)
www.appmillers.com
20
15 30
10
5
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Left
Right
Left rotation
25 35
Right rotation
AVL Tree - Insert a Node (All together)
www.appmillers.com
20
10 30
15 5
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Right
Right
Left rotation
25 35
50
60
AVL Tree - Insert a Node (All together)
www.appmillers.com
20
10 30
15 5
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Right
Right
Left rotation
25 50
35 60
70
AVL Tree - Insert a Node (All together)
www.appmillers.com
20
10 50
15 5
- Left Left condition (LL)
- Left Right condition (LR)
- Right Right condition (RR)
- Right Left condition (RL)
30,25,35,20,15,5,10,50,60,70,65
Left
Right
Right rotation
30 60
25 35 70
65
Left rotation
AVL Tree - Insert a Node (All together)
www.appmillers.com
AVL Tree - Delete a Node
Case 1 - Rotation is not required
Case 2 - Rotation is required (LL, LR, RR, RL) 70
50 90
30 60
20 40
80 100
www.appmillers.com
AVL Tree - Delete a Node
70
50 90
30 60
20 40
80 100
- The node to be deleted is a leaf node
Case 1 - Rotation is not required
www.appmillers.com
70
50 90
30 60
20
80 100
www.appmillers.com
- The node to be deleted has a child node
Case 1 - Rotation is not required
AVL Tree - Delete a Node
70
50 90
30 60
20
80 100
40
80
85
www.appmillers.com
AVL Tree - Delete a Node
- The node to be deleted has two children node
Case 1 - Rotation is not required
70
50 90
30 60
20
80 100
40
70
85
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
Case 2 - Rotation is required
www.appmillers.com
AVL Tree - Delete a Node
70
50 90
30 60
20
80 100
70
85
Left Left Condition (LL)
Left
Left
Right rotation
www.appmillers.com
AVL Tree - Delete a Node
Case 2 - Rotation is required
70
50 90
30 60
20
80 100
70
85
Left
Right
Left rotation
www.appmillers.com
AVL Tree - Delete a Node
Left Right Condition (LR)
Case 2 - Rotation is required
70
50 90
30 60
20
85
70
80
Right rotation
www.appmillers.com
AVL Tree - Delete a Node
Left Right Condition (LR)
Case 2 - Rotation is required
70
50 90
30 60
70
80 100
70
85
Right
Right
Left rotation
www.appmillers.com
AVL Tree - Delete a Node
Right Right Condition (RR)
Case 2 - Rotation is required
70
50 90
30 60
55
80 100
70
85
Right
Left
Right rotation
www.appmillers.com
AVL Tree - Delete a Node
Right Left Condition (RL)
Case 2 - Rotation is required
70
50 90
55
60
80 100
70
85
Left rotation
www.appmillers.com
AVL Tree - Delete a Node
Right Left Condition (RL)
Case 2 - Rotation is required
70
50 90
30 60
20
80 100
40
70
110
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
65
15
Right rotation
Delete 40
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
50 90
20 60
15
80 100
30
70
110
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
65
Delete 15
The tree is balanced
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
50 90
20 60 80 100
30
70
110
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
65
Delete 65
The tree is balanced
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
50 90
20 60 80 100
30
70
110
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
Delete 60
The tree is disbalanced
Left rotation
Right rotation
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
30 90
20 50 80 100
70
110
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
Delete 80
The tree is disbalanced
Left rotation
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
30 100
20 50 90 110
80
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
Insert 105
105
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
30 100
20 50 90 110
80
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
Delete 90
105
Right rotation
Left rotation
www.appmillers.com
AVL Tree - Delete a Node (all together)
70
10
15
5
20
- Left Left Condition (LL)
- Left Right Condition (LR)
- Right Right Condition (RR)
- Right Left Condition (RL)
10
5 15
20
www.appmillers.com
AVL Tree - Delete a Node (all together)
AVL Tree - Delete
70
50 90
30 60
20 40
80 100
rootNode = Null
www.appmillers.com
Time complexity Space complexity
Create AVL O(1) O(1)
Insert a node AVL O(logN) O(logN)
Traverse AVL O(N) O(N)
Search for a node AVL O(logN) O(logN)
Delete node from AVL O(logN) O(logN)
Delete Entire AVL O(1) O(1)
www.appmillers.com
Time and Space Complexity of AVL
BST AVL
Create Tree O(1) O(1)
Insert a node Tree O(N) O(logN)
Traverse Tree O(N) O(N)
Search for a node Tree O(N) O(logN)
Delete node from Tree O(N) O(logN)
Delete Entire Tree O(1) O(1)
www.appmillers.com
Binary Search Tree vs AVL Tree
Binary Heap
5
10 30
15 20
What is a Binary Heap?
www.appmillers.com
5
10 20
30 40
70 80
50 60
A Binary Heap is a Binary Tree with following properties.
- A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in
Binary Heap. The same property must be recursively true for all nodes in Binary Tree.
- It’s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This
property of Binary Heap makes them suitable to be stored in an array.
Why we need a Binary Heap?
Find the minimum or maximum number among a set of numbers in logN time. And also we want to make sure
that inserting additional numbers does not take more than O(logN) time
Possible Solutions
- Store the numbers in sorted Array
10 20 30 40 50
Find minimum: O(1)
5
Insertion: O(n)
- Store the numbers in Linked List in sorted manner
Head 111 3 null
333
2 333
222
1 222
111
Tail 333 null
4
www.appmillers.com
Find the minimum or maximum number among a set of numbers in logN time. And also we want to
make sure that inserting additional numbers does not take more than O(logN) time
Practical Use
- Prim’s Algorithm
- Heap Sort
- Priority Queue
www.appmillers.com
Why we need a Binary Heap?
Types of Binary Heap
Min heap - the value of each node is less than or equal to the value of both its children.
Max heap - it is exactly the opposite of min heap that is the value of each node is more than or equal to the value
of both its children.
80
70 60
50 40
5 10
30 20
www.appmillers.com
5
10 20
30 40
70 80
50 60
Common Operations on Binary Heap
- Creation of Binary Heap,
- Peek top of Binary Heap
- Extract Min / Extract Max
- Traversal of Binary Heap
- Size of Binary Heap
- Insert value in Binary Heap
- Delete the entire Binary heap
Implementation Options
- Array Implementation
- Reference /pointer Implementation
www.appmillers.com
5
10 20
30 40
70 80
50 60
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
Left child = cell[2x]
Right child = cell[2x+1]
www.appmillers.com
Common Operations on Binary Heap
5
10 20
30 40 50 60
0 1 2 3 4 5 6 7 8
- Creation of Binary Heap
Initialize Array
set size of Binary Heap to 0
www.appmillers.com
Common Operations on Binary Heap
5
10 20
30 40 50 60
- Peek of Binary Heap
Return Array[1]
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
www.appmillers.com
Common Operations on Binary Heap
- Size Binary Heap
Return number of filled cells
www.appmillers.com
Common Operations on Binary Heap
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
5
10 20
30 40 50 60
5
10 20
30 40 50 60
- Level Order Traversal
www.appmillers.com
Common Operations on Binary Heap
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
Binary Heap - Insert a Node
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
5
10 20
30 40 50 60
1
www.appmillers.com
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
5
10 20
30 40 50 60
1
1
1 30
www.appmillers.com
Binary Heap - Insert a Node
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
5
10 20
1 40 50 60
30
5 101 30
www.appmillers.com
Binary Heap - Insert a Node
Binary Heap - Extract a Node
5 10 20 30 40 50 60
0 1 2 3 4 5 6 7 8
5
10 20
30 40 50 60
80
80
www.appmillers.com
20 30 40 50 60
0 1 2 3 4 5 6 7 8
80
10 20
30 40 50 60
80 10
www.appmillers.com
Binary Heap - Extract a Node
10 20 40 50 60
0 1 2 3 4 5 6 7 8
10
80 20
30 40 50 60
80 30
www.appmillers.com
Binary Heap - Extract a Node
Binary Heap - Delete
10 80 20 30 40 50 60
0 1 2 3 4 5 6 7 8
10
80 20
30 40 50 60
array = Null
www.appmillers.com
Time and Space Complexity of Binary Heap
Time complexity Space complexity
Create Binary Heap O(1) O(N)
Peek of Heap O(1) O(1)
Size of Heap O(1) O(1)
Traversal of Heap O(N) O(1)
Insert a node to Binary Heap O(logN) O(logN)
Extract a node from Binary Heap O(logN) O(logN)
Delete Entire Binary Heap O(1) O(1)
www.appmillers.com
Trie
R
E
S
M
L
A Trie is a tree-based data structure that organizes information in a hierarchy.
Properties:
- It is typically used to store or search strings in a space and time efficient way.
- Any node in trie can store non repetitive multiple characters
- Every node stores link of the next character of the string
- Every node keeps track of ‘end of string’
AIR, AIT, BAR, BIL, BM
AB
I AIM
RT R L
What is a Trie?
www.appmillers.com
What is a Trie?
AIR
A
I
R
A Trie is a tree-based data structure that organizes information in a hierarchy.
www.appmillers.com
What is a Trie?
AIT
A
I
RTR
www.appmillers.com
A Trie is a tree-based data structure that organizes information in a hierarchy.
What is a Trie?
BAR A
I
R
AB
A
RT R
www.appmillers.com
A Trie is a tree-based data structure that organizes information in a hierarchy.
What is a Trie?
BIL A
I
RTR
AB
A
R
AI
L
www.appmillers.com
A Trie is a tree-based data structure that organizes information in a hierarchy.
What is a Trie?
BM
A
I
RTR
AB
A
R
AI
L
AIM
www.appmillers.com
A Trie is a tree-based data structure that organizes information in a hierarchy.
Whe we need Trie?
To solve many standard problems in efficient way
A
I
RTR
AB
A
R
AI
L
AIM
- Spelling checker
- Auto completion
www.appmillers.com
Why we need Trie?
A
I
RTR
AB
A
R
AI
L
Map AIM
Characters Link to Trie Node
End of String
www.appmillers.com
To solve many standard problems in efficient way
- Spelling checker
- Auto completion
Common Operations on Trie
- Creation of Trie
- Insertion in Trie
- Search for a String in trie
- Deletion from Trie
A
I
RTR
AB
A
R
AI
L
AIM
www.appmillers.com
Common Operations on Trie
- Creation of Trie
Map
Characters Link to Trie Node
End of String
Initialize Trie() class
Logical
Physically
www.appmillers.com
Insert a String in a Trie
Case 1 : A Trie is Blank
Map
Characters Link to Trie Node
End of String = N
APP
A
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = Y
www.appmillers.com
Case 2: New string’s prefix is common to another strings prefix
Map
Characters Link to Trie Node
End of String = N
API
A
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = Y
I
Map
Characters Link to Trie Node
End of String = Y
www.appmillers.com
Insert a String in a Trie
Case 3: New string’s prefix is already present as complete string
Map
Characters Link to Trie Node
End of String = N
APIS
A
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = Y
I
Map
Characters Link to Trie Node
End of String = Y
S
Map
Characters Link to Trie Node
End of String = Y www.appmillers.com
Insert a String in a Trie
Case 4: String to be inserted is already presented in Trie
Map
Characters Link to Trie Node
End of String = N
APIS
A
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = N
P
Map
Characters Link to Trie Node
End of String = Y
I
Map
Characters Link to Trie Node
End of String = Y
S
Map
Characters Link to Trie Node
End of String = Y www.appmillers.com
Insert a String in a Trie
Search for a String in a Trie
Case 1: String does not exist in Trie
BCD
B
Return : The string does not exist in Trie
A
P
I
www.appmillers.com
Search for a String in a Trie
Case 2: String exists in Trie
API
A
P
I
Return : TRUE
www.appmillers.com
Search for a String in a Trie
Case 3: String is a prefix of another string, but it does not exist in a Trie
AP
A
P
I
Return : FALSE
www.appmillers.com
Delete a String from Trie
Case 1: Some other prefix of string is same as the one that we want to delete. (API, APPLE)
A
P
I P
L
E
www.appmillers.com
Delete a String from Trie
Case 2: The string is a prefix of another string. (API, APIS)
A
P
I
S
P
L
E
www.appmillers.com
Delete a String from Trie
Case 3: Other string is a prefix of this string. (APIS, AP)
A
P
S
I
Dictionary
Characters Link to Trie Node
End of String = N
A
Dictionary
Characters Link to Trie Node
End of String = N
P
Dictionary
Characters Link to Trie Node
End of String = Y
I
Dictionary
Characters Link to Trie Node
S
End of String = N
Dictionary
Characters Link to Trie Node
End of String = Y
www.appmillers.com
Delete a String from Trie
Case 4: Not any node depends on this String (K)
AK
P
S
I
A Dictionary
Characters Link to Trie Node
A
End of String = N
K
Dictionary
Characters Link to Trie Node
P
End of String = N Dictionary
Characters Link to Trie Node
I
End of String = N
Dictionary
Characters Link to Trie Node
End of String = Y
www.appmillers.com
Practical use of Trie
- Spelling checker
- Auto completion
www.appmillers.com
Hashing
What is Hashing?
Hashing is a method of sorting and indexing data. The idea behind hashing is to allow large amounts of data to
be indexed using keys commonly created by formulas
Apple
Application
Appmillers
Magic function
18
20
22
..
0 1 .. 18 19 20 21 22 23
Apple Application Appmillers
www.appmillers.com
Why Hashing?
It is time efficient in case of SEARCH Operation
Data Structure Time complexity for SEARCH
Array O(logN)
Linked List O(N)
Tree O(logN)
Hashing O(1) / O(N)
www.appmillers.com
Hashing Terminology
Hash function : It is a function that can be used to map of arbitrary size to data of fixed size.
Apple
Application
Appmillers
Magic function
18
20
22
..
0 1 .. 18 19 20 21 22 23
Apple Application Appmillers
Hash Function
Key : Input data by a user
Key
Hash value : A value that is returned by Hash Function
Hash Value
Hash Table : It is a data structure which implements an associative array abstract data type, a structure that can
map keys to values
Hash Table
Collision : A collision occurs when two different keys to a hash function produce the same output.
www.appmillers.com
ABCD
ABCDEF
Hash function
20
20
..
0 1 .. 18 19 20 21 22 23
ABCD
ABCDEF
Collision
�
www.appmillers.com
Hashing Terminology
Hash function : It is a function that can be used to map of arbitrary size to data of fixed size.
Key : Input data by a user
Hash value : A value that is returned by Hash Function
Hash Table : It is a data structure which implements an associative array abstract data type, a structure that can
map keys to values
Collision : A collision occurs when two different keys to a hash function produce the same output.
Hash Functions
int mod(int number, int cellNumber) {
 return number % cellNumber;
}
.. .. ..
0 1 .. 4 5 .. 16 .. 23
mod(400, 24) 16
mod(700, 24) 4
700 400
Mod function
www.appmillers.com
.. .. ..
0 1 . 6 7 .. 16 .. 23
6
ABC
ASCII function
public int modASCII(String word, int cellNumber) {
 int total = 0;
 for (int i=0; i<word.length(); i++) {
 total += word.charAt(i);
 System.out.println(total);
 }
 return total % cellNumber;
}
modASCII("ABC", 24)
A
B
C
65
66
67
65+66+67 = 198 24
192 8
6
www.appmillers.com
Hash Functions
Hash Functions
Properties of good Hash function
- It distributes hash values uniformly across hash tables
ABCD
ABCDEF
Hash function
20
20
..
0 1 .. 18 19 20 21 22 23
ABCD
ABCDEF
Collision
�
www.appmillers.com
Hash Functions
ABCD
ABCDEF
Hash function
18
..
0 1 .. 18 19 20 21 22 23
ABCD
Collision �
- It has to use all the input data
ABC
www.appmillers.com
Properties of good Hash function
- It distributes hash values uniformly across hash tables
EFGH
Collision Resolution Techniques
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
ABCD
EFGH
Hash function
2
ABCD
IJKLM
2
Collision
�
www.appmillers.com
Collision Resolution Techniques
Resolution Techniques
Direct Chaining Open Addressing
Linear Probing
Quadratic Probing
Double Hashing
www.appmillers.com
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Direct Chaining : Implements the buckets as linked list. Colliding elements are stored in this lists
ABCD
EFGH
Hash function
2
111
IJKLM
2
2
ABCD Null
111
EFGH Null
222
IJKLM Null
333
222 333
Miller 7
Miller Null
444
444
www.appmillers.com
Collision Resolution Techniques
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Open Addressing: Colliding elements are stored in other vacant buckets. During storage and lookup these are found
through so called probing.
ABCD
EFGH
Hash function
2
ABCD
IJKLM
2
2
Linear probing : It places new key into closest following empty cell
EFGH
IJKLM
www.appmillers.com
Collision Resolution Techniques
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
ABCD
EFGH
IJKLM
12, 22, 32, 42..
2 + 12 = 3
2 + 22 = 6
www.appmillers.com
Collision Resolution Techniques
Open Addressing: Colliding elements are stored in other vacant buckets. During storage and lookup these are found
through so called probing.
Quadratic probing : Adding arbitrary quadratic polynomial to the index until an empty cell is found
ABCD
EFGH
Hash function
2
IJKLM
2
2
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
ABCD
EFGH
Hash Function 2
2
ABCD
IJKLM
2
2
EFGH
IJKLM
Hash function
EFGH
IJKLM
4
4
2 + 4 = 6
2 + 4 = 6
2 + (2*4) = 8
www.appmillers.com
Collision Resolution Techniques
Open Addressing: Colliding elements are stored in other vacant buckets. During storage and lookup these are found
through so called probing.
Double Hashing : Interval between probes is computed by another hash function
Hash Table is Full
Direct Chaining
This situation will never arise.
www.appmillers.com
ABCD
EFGH
2
IJKLM
1
3
Hash function
NOPQ 0
RSTU 1
111
222
333
444
0
1
2
3
NOPQ Null
111
EFGH Null
222
ABCD Null
333
555
IJKLM Null
444
RSTU Null
555
Open addressing
Create 2X size of current Hash Table and recall hashing for current keys
www.appmillers.com
Hash Table is Full
ABCD
EFGH
2
IJKLM
1
3
Hash function
NOPQ 0
RSTU 1
0
1
2
3
4
5
6
7
ABCD
NOPQ
EFGH
ABCD
IJKLM
0
1
2
3
NOPQ
EFGH
IJKLM
RSTU
Pros and Cons of Collision Resolution Techniques
Direct chaining
- Hash table never gets full
- Huge Linked List causes performance leaks (Time complexity for search operation becomes O(n).)
Open addressing
- Easy Implementation
- When Hash Table is full, creation of new Hash table affects performance (Time complexity for search
operation becomes O(n).)
‣ If the input size is known we always use “Open addressing”
‣ If we perform deletion operation frequently we use “Direct Chaining”
www.appmillers.com
ABCD
EFGH
2
IJKLM
1
3
Hash function
NOPQ 0
RSTU 1
www.appmillers.com
Pros and Cons of Collision Resolution Techniques
NOPQ
EFGH
ABCD
IJKLM
0
1
2
3
4 RSTU
Linear Probing
Practical Use of Hashing
Password verification
Personal Computer
Google Servers
Login : elshad@google.com
Password: 123456
Hash value: *&71283*a12
www.appmillers.com
Practical Use of Hashing
Password verification
File system : File path is mapped to physical location on disk
www.appmillers.com
Practical Use of Hashing
File system : File path is mapped to physical location on disk
Path: /Documents/Files/hashing.txt
www.appmillers.com
0
1
2
3
Physical location: sector 4 /Documents/
Files/hashing.txt
Pros and Cons of Hashing
✓On an average Insertion/Deletion/Search operations take O(1) time.
x When Hash function is not good enough Insertion/Deletion/Search operations take O(n) time
Operations Array Linked List Tree Hashing
Insertion O(N) O(N) O(LogN) O(1)/O(N)
Deletion O(N) O(N) O(LogN) O(1)/O(N)
Search O(N) O(N) O(LogN) O(1)/O(N)
www.appmillers.com
Sorting Algorithms 1 2 3 4 5
What is Sorting?
By definition sorting refers to arranging data in a particular format : either ascending or descending.
www.appmillers.com
www.appmillers.com
What is Sorting?
By definition sorting refers to arranging data in a particular format : either ascending or descending.
What is Sorting?
Practical Use of Sorting
Microsoft Excel : Built in functionality to sort data
Online Stores: Online shopping websites generally have option sor sorting by price, review,
ratings..
www.appmillers.com
Sorting
Space used Stability
In pace Out of place Stable Unstable
www.appmillers.com
Types of Sorting
Types of Sorting
Space used
In place sorting : Sorting algorithms which does not require any extra space for sorting
Example : Bubble Sort
70 10 80 30 20 40 60 50 90
10 20 30 40 50 60 70 80 90
Out place sorting : Sorting algorithms which requires an extra space for sorting
Example : Merge Sort
70 10 80 30 20 40 60 50 90
10 20 30 40 50 60 70 80 90
www.appmillers.com
Types of Sorting
Stability
Stable sorting : If a sorting algorithm after sorting the contents does not change the sequence of
similar content in which they appear, then this sorting is called stable sorting.
Example : Insertion Sort
70 10 80 40 20 40 60 50 90
10 20 40 40 50 60 70 80 90
UnStable sorting : If a sorting algorithm after sorting the content changes the sequence of similar
content in which they appear, then it is called unstable sort.
Example : Quick Sort
70 10 80 40 20 40 60 50 90
10 20 40 40 50 60 70 80 90
www.appmillers.com
Stability
UnStable sorting example
Unsorted data
Name Age
Renad 7
Nick 6
Richard 6
Parker 7
Sofia 7
Sorted by name
Name Age
Nick 6
Parker 7
Renad 7
Richard 6
Sofia 7
Sorted by age (stable)
Name Age
Nick 6
Richard 6
Parker 7
Renad 7
Sofia 7
Sorted by age (unstable)
Name Age
Nick 6
Richard 6
Renad 7
Parker 7
Sofia 7
{
www.appmillers.com
Types of Sorting
Increasing Order
- If successive element is greater than the previous one
- Example : 1, 3, 5, 7, 9 ,11
Decreasing Order
- If successive element is less than the previous one
- Example : 11, 9, 7, 5, 3, 1
Non Increasing Order
- If successive element is less than or equal to its previous element in the sequence.
- Example : 11, 9, 7, 5, 5, 3, 1
Non Decreasing Order
- If successive element is greater than or equal to its previous element in the sequence
- Example : 1, 3, 5, 7, 7, 9, 11
www.appmillers.com
Sorting Terminology
Bubble sort
Selection sort
Insertion sort
Bucket sort
Merge sort
Quick sort
Heap sort
Which one to select?
- Stability
- Space efficient
- Time efficient
www.appmillers.com
Sorting Algorithms
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
5 9 3 1 2 8 4 7 6
www.appmillers.com
5 3 1 2 8 4 7 6 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
3 1 2 5 4 7 6 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
1 2 3 4 5 6 7 8 9
www.appmillers.com
Bubble Sort
- Bubble sort is also referred as Sinking sort
- We repeatedly compare each pair of adjacent items and swap them if they are in the wrong order
When to use Bubble Sort?
- When the input is almost sorted
When to avoid Bubble Sort?
- Average time complexity is poor
- Space is a concern
- Easy to implement
www.appmillers.com
Bubble Sort
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
5 7 4 3 8 6 1 9 2
min
1
Sorted array Unsorted array
www.appmillers.com
7 4 3 8 6 5 9 22
min
1 2
Sorted array Unsorted array
www.appmillers.com
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
Selection Sort
4 33 8 6 5 9 7
min
1 2
Sorted array Unsorted array
3
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 8 6 5 9 7
min
1 2
Sorted array Unsorted array
3 4
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 8 6 5 9 7
min
1 2
Sorted array Unsorted array
3 5
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 6 8 9 7
min
1 2
Sorted array Unsorted array
3 5 6
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 6 8 9 7
min
1 2
Sorted array Unsorted array
3 5 7
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 6 9 8
min
1 2
Sorted array Unsorted array
3 5 7 8 8
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
4 6 99
min
1 2
Sorted array Unsorted array
3 5 7 8 9
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
1 2 3 4 6 9
Sorted array Unsorted array
5 7 8
www.appmillers.com
Selection Sort
- In case of selection sort we repeatedly find the minimum element and move it to the sorted part of array
to make unsorted part sorted.
When to use Selection Sort?
- When we have insufficient memory
When to avoid Selection Sort?
- When time is a concern
- Easy to implement
www.appmillers.com
Selection Sort
Insertion Sort
5 34 7 8
- Divide the given array into two part
- Take first element from unsorted array and find its correct position in sorted array
- Repeat until unsorted array is empty
Sorted array Unsorted array
32 4 2 6 9 1
www.appmillers.com
4 5 7 8 9
- Divide the given array into two part
- Take first element from unsorted array and find its correct position in sorted array
- Repeat until unsorted array is empty
Sorted array Unsorted array
2 3 6 6 1
www.appmillers.com
Insertion Sort
4 5 7 8 9
- Divide the given array into two part
- Take first element from unsorted array and find its correct position in sorted array
- Repeat until unsorted array is empty
Sorted array Unsorted array
12 3 6 1
www.appmillers.com
Insertion Sort
When to use Insertion Sort?
- When we have insufficient memory
When to avoid Insertion Sort?
- When time is a concern
- Easy to implement
- When we have continuous inflow of numbers and we want to keep them sorted
www.appmillers.com
Insertion Sort
5 3 7 8
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
4 2 6 9 1
- Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
- Appropriate bucket = ceil(Value * number of buckets / maxValue)
 ceil(5*3/9) = ceil(1.6) = 2
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
5
3 7 8
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
4 2 6 9 1
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
 ceil(3*3/9) = ceil(1) = 1 ceil(4*3/9) = ceil(1.3) = 2
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
5
7 8
3
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
6 9
4
2 1
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
 ceil(7*3/9) = ceil(2.3) = 3 ceil(2*3/9) = ceil(0.6) = 1
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
5
8
3 7
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
6 9
2 4
1
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
 ceil(8*3/9) = ceil(2.6) = 3 ceil(6*3/9) = ceil(2) = 2
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
3 5 7 8
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
9
2 4 6
1
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
 ceil(9*3/9) = ceil(3) = 3 ceil(1*3/9) = ceil(0.3) = 1 Sort all buckets (using any sorting algorithm)
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
3 5 7 8
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
2 1 4 6 9
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
Sort all buckets (using any sorting algorithm)
www.appmillers.com
Bucket Sort
Bucket 1 Bucket 2 Bucket 3
Bucket 1 Bucket 2 Bucket 3
- Create buckets and distribute elements of array into buckets
- Sort buckets individually
- Merge buckets after sorting
1 2 3 4 5 6 7 8 9
Number of buckets = round(Sqrt(number of elements))
round(sqrt(9)) = 3
Appropriate bucket = ceil(Value * number of buckets / maxValue)
Sort all buckets (using any sorting algorithm)
www.appmillers.com
Bucket Sort
When to use Bucket Sort?
- When input uniformly distributed over range
When to avoid Bucket Sort?
- When space is a concern
1,2,4,5,3,8,7,9 1,2,4,91,93,95
www.appmillers.com
Bucket Sort
- Merge sort is a divide and conquer algorithm
- Divide the input array in two halves and we keep halving recursively until they become too
small that cannot be broken further
- Merge halves by sorting them
www.appmillers.com
Merge Sort
6 4 3 7 5 1 2
www.appmillers.com
Merge Sort
6 4 3 7 5 1 2
www.appmillers.com
Merge Sort
When to use Merge Sort?
- When you need stable sort
When to avoid Merge Sort?
- When space is a concern
- When average expected time is O(NlogN)
www.appmillers.com
Merge Sort
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger numbers
are located at the right of the pivot.
- Unlike merge sort extra space is not required
70 10 80 30 90 40 60 20 50
10 30 40 20 50 80 60 70 90
10 20 40 30 50 80 60 70 90
10 20 30 40 50 80 60 70 90
10 20 30 40 50 80 60 70 90
10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80 90
www.appmillers.com
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
3 5 8 1 2 9 4 7 6
L L R R P
www.appmillers.com
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
3 5 4 1 2 9 8 7 6
L L R P L R
www.appmillers.com
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
3 5 4 1 2 6 8 7 9
L R P L R
www.appmillers.com
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
1 2 4 3 5 6 8 7 9
L R PL P
1 5
www.appmillers.com
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
2 4 3 5 6 8 7 9
L R P
1 3 4
L LRR PL P
9
www.appmillers.com
Quick Sort
- Quick sort is a divide and conquer algorithm
- Find pivot number and make sure smaller numbers located at the left of pivot and bigger
numbers are located at the right of the pivot.
- Unlike merge sort extra space is not required
1 2 3 4 5 6 8 7 9
L R P
7 8
www.appmillers.com
Quick Sort
When to use Quick Sort?
- When you need stable sort
When to avoid Quick Sort?
- When space is a concern
- When average expected time is O(NlogN)
www.appmillers.com
Quick Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
- It is best suited with array, it does not work with Linked List
Binary Heap is a binary tree with special properties
- The value of any given node must be less or equal of its children (min heap)
- The value of any given node must be greater or equal of its children (max heap)
5
10 20
30 40
70 80
50 60
www.appmillers.com
Heap Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
15
15 10 40 20 50 10 30 45 5
10 40
20 50 10 30
www.appmillers.com
Heap Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
10
15 10 40 20 50 10 30 45 5
15 10
20 50 40 30
45 5
www.appmillers.com
Heap Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
5
10 10
15 50 40 30
45 20
5 10
www.appmillers.com
Heap Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
10
15 30
20 50 40 45
5 10 10 15 20 30
www.appmillers.com
Heap Sort
- Step 1 : Insert data to Binary Heap Tree
- Step 2 : Extract data from Binary Heap
40
45 50
5 10 10 15 20 30 40 45 50
www.appmillers.com
Heap Sort
Name Time Complexity Space Complexity Stable
Bubble Sort O(n2) O(1) Yes
Selection Sort O(n2) O(1) No
Insertion Sort O(n2) O(1) Yes
Bucket Sort O(n logn) O(n) Yes
Merge Sort O(n logn) O(n) Yes
Quick Sort O(n logn) O(n) No
Heap Sort O(n logn) O(1) No
www.appmillers.com
Sorting Algorithms
Linear Search in Java
www.appmillers.com
Linear Search Pseudocode
- Create function with two parameters which are an array and a value
- Loop through the array and check if the current array element is equal to the value
- If it is return the index at which the element is found
- If the value is never found return -1
www.appmillers.com
Binary Search in Java
www.appmillers.com
Binary Search Pseudocode
- Create function with two parameters which are a sorted array and a value
- Create two pointers : a left pointer at the start of the array and a right pointer at the
end of the array.
- Based on left and right pointers calculate middle pointer
- While middle is not equal to the value and start<=end loop:
 - if the middle is greater than the value move the right pointer down
 - if the middle is less than the value move the left pointer up
- If the value is never found return -1
www.appmillers.com
Graph
What is a graph? Why do we need it?
Graph Terminologies
Types of graphs. Graph Representation
Traversal of graphs. (BFS and DFS)
Topological Sorting
Single source shortest path (BFS, Dijkstra and Bellman Ford )
All pairs shortest path (BFS, Dijkstra, Bellman Ford and Floyd Warshall algorithms)
Minimum Spanning Tree (Kruskal and Prim algorithms)
www.appmillers.com
What you will learn
What is a Graph?
Graph consists of a finite set of Vertices(or nodes) and a set of Edges which connect a pair of nodes.
B
E
D
J
C
A
Node
Edge
www.appmillers.com
Why Graph?
www.appmillers.com
Graph Terminology
V2
V3
V5
V4
V1
- Vertices (vertex) : Vertices are the nodes of the graph
- Edge : The edge is the line that connects pairs of vertices
www.appmillers.com
V2
V3
V5
V4
V1
- Vertices : Vertices are the nodes of the graph
- Edge : The edge is the line that connects pairs of vertices
- Unweighted graph : A graph which does not have a weight associated with any edge
- Weighted graph : A graph which has a weight associated with any edge
- Undirected graph : In case the edges of the graph do not have a direction associated with them
- Directed graph : If the edges in a graph have a direction associated with them
8 12
www.appmillers.com
Graph Terminology
V2
V3
V5
V4
V1
- Vertices : Vertices are the nodes of the graph
- Edge : The edge is the line that connects pairs of vertices
- Weighted graph : A graph which has a weight associated with any edge
- Undirected graph : In case the edges of the graph do not have a direction associated with them
- Directed graph : If the edges in a graph have a direction associated with them
- Cyclic graph : A graph which has at least one loop
- Unweighted graph : A graph which does not have a weight associated with any edge
www.appmillers.com
Graph Terminology
V2
V3
V5
V1
- Vertices : Vertices are the nodes of the graph
- Edge : The edge is the line that connects pairs of vertices
- Weighted graph : A graph which has a weight associated with any edge
- Undirected graph : In case the edges of the graph do not have a direction associated with them
- Directed graph : If the edges in a graph have a direction associated with them
- Cyclic graph : A graph which has at least one loop
- Acyclic graph : A graph with no loop
- Unweighted graph : A graph which does not have a weight associated with any edge
www.appmillers.com
Graph Terminology
V2 V3
V5
V1
- Vertices : Vertices are the nodes of the graph
- Edge : The edge is the line that connects pairs of vertices
- Weighted graph : A graph which has a weight associated with any edge
- Undirected graph : In case the edges of the graph do not have a direction associated with them
- Directed graph : If the edges in a graph have a direction associated with them
- Cyclic graph : A graph which has at least one loop
- Acyclic graph : A graph with no loop
- Tree: It is a special case of directed acyclic graphs
- Unweighted graph : A graph which does not have a weight associated with any edge
www.appmillers.com
Graph Terminology
Graph
Directed Undirected
Weighted Unweighted Weighted Unweighted
Positive Negative Positive Negative
www.appmillers.com
Graph Types
1. Unweighted - undirected
V2
V3
V5
V4
V1
www.appmillers.com
Graph Types
1. Unweighted - undirected
V2
V3
V5
V4
V1
2. Unweighted - directed
www.appmillers.com
Graph Types
1. Unweighted - undirected
2. Unweighted - directed
3. Positive - weighted - undirected
V2
V3
V5
V4
V1
4
3
5
3
2
3
www.appmillers.com
Graph Types
1. Unweighted - undirected
2. Unweighted - directed
3. Positive - weighted - undirected
4. Positive - weighted - directed
V2
V3
V5
V4
V1
4
3
5
3
2
3
www.appmillers.com
Graph Types
1. Unweighted - undirected
2. Unweighted - directed
3. Positive - weighted - undirected
4. Positive - weighted - directed
V2
V3
V5
V4
V1
4
3
-5
-3
2
3
5. Negative - weighted - undirected
www.appmillers.com
Graph Types
1. Unweighted - undirected
2. Unweighted - directed
3. Positive - weighted - undirected
4. Positive - weighted - directed
V2
V3
V5
V4
V1
4
3
-5
-3
2
3
5. Negative - weighted - undirected
6. Negative - weighted - directed
www.appmillers.com
Graph Types
Adjacency Matrix : an adjacency matrix is a square matrix or you can say it is a 2D array. And the elements of the
matrix indicate whether pairs of vertices are adjacent or not in the graph
C
B
E
D
A 0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
A B C D E
A
B
C
D
E
1 1 1
1 1
1 1
1 1 1
1 1
www.appmillers.com
Graph Representation
Adjacency List : an adjacency list is a collection of unordered list used to represent a graph. Each list describes the
set of neighbors of a vertex in the graph.
C
B
E
D
A
A
B
C
D
E
B C D
A E
A D
A C E
B D
www.appmillers.com
Graph Representation
If the number of edges are few then we should use Adjacency List
C
B
E
D
A
A
B
C
D
E
B C D
A E
A D
A C E
B D
If a graph is complete or almost complete we should use Adjacency Matrix
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
A B C D E
A
B
C
D
E
1 1 1
1 1
1 1
1 1 1
1 1
www.appmillers.com
Graph Representation
Graph Traversal
Graph Traversal
C
B
D G
A
It is a process of visiting all vertices in a given Graph
E F
- Breadth First Search
- Depth First Search
www.appmillers.com
Breadth First Search (BFS)
BFS is an algorithm for traversing Graph data structure. It starts at some arbitrary node of a graph and explores
the neighbor nodes (which are at current level) first, before moving to the next level neighbors.
C
B
D G
A
E F
Level 1
Level 2
Level 3
www.appmillers.com
Breadth First Search Algorithm
C
B
D G
A
E F
BFS
 enqueue any starting vertex
while queue is not empty
p = dequeue()
if p is unvisited
mark it visited
enqueue all adjacent
unvisited vertices of p
Queue A C D G E F
A
B
B C D G E F
www.appmillers.com
BFS
while all vertices are not explored
 enqueue any starting vertex
 while queue is not empty
 p = dequeue()
 if p is unvisited
 mark it visited
enqueue unvisited adjacent vertices of p
}
Time and Space Complexity of BFS
www.appmillers.com
O(1)
O(V)
O(1)
O(1)
O(1)
O(Adj)
O(V)
}O(Adj)
O(E)
Time Complexity : O(V+E)
Space Complexity : O(V+E)
Depth First Search (DFS)
DFS is an algorithm for traversing a graph data structure which starts selecting some arbitrary node and explores
as far as possible along each edge before backtracking
C
B
D G
A
E F
www.appmillers.com
C
B
D G
A
E F
DFS
 push any starting vertex
while stack is not empty
p = pop()
if p is unvisited
mark it visited
Push all adjacent
unvisited vertices of p
A
C
D
G
E
F
G
Stack
B
A C E F D B G
D
B
www.appmillers.com
Depth First Search Algorithm
DFS
while all vertices are not explored
 push any starting vertex
 while stack is not empty
 p = pop()
 if p is unvisited
 mark it visited
push unvisited adjacent vertices of p
}
Time and Space Complexity of DFS
www.appmillers.com
O(1)
O(V)
O(1)
O(1)
O(1)
O(Adj)
O(V)
}O(Adj)
O(E)
Time Complexity : O(V+E)
Space Complexity : O(V+E)
C
B
D G
A
E F
Level 1
Level 2
Level 3
C
B
D G
A
E F
BFS DFS
www.appmillers.com
BFS vs DFS
BFS DFS
How does it work internally? It goes in breath first It goes in depth first
Which DS does it use internally? Queue Stack
Time Complexity O(V+E) O(V+E)
Space Complexity O(V+E) O(V+E)
When to use? If we know that the target is close to the
staring point
If we already know that the target vertex is
buried very deep
www.appmillers.com
BFS vs DFS
Topological Sort
Topological Sort
Topological Sort: Sorts given actions in such a way that if there is a dependency of one action on another, then the
dependent action always comes later than its parent action.
Exercise
Bath
Breakfast
Work
Buy
breakfast
fruits
Prepare
Breakfast
Wash
dishes
Topological Sort Algorithm
Stack
C
B
G
D
A
E
H F
H
F
E
D
C
A
G
B
 if a vertex depends on currentVertex:
Go to that vertex and
then come back to currentVertex
else
Push currentVertex to Stack
A B C D E H F G
B A C D E H F G
B D A C E F G H
topologicalSort(G)
 for all nodes
 if vertex not visited
 topologicalVisit(node)
}
Time and Space Complexity of Topological Sort
www.appmillers.com
} O(V)
O(E)
Time Complexity : O(V+E)
Space Complexity : O(V+E)
C
B
G
D
A
E
H F
topologicalVisit(node)
 for each nodes
 if not visited
 topologicalVisit(neighbor)
Single Source Shortest
Path Problem (SSSPP)
A single source problem is about finding a path between a given vertex (called source) to all other vertices in
a graph such that the total distance between them (source and destination) is minimum.
The problem:
- Five offices in different cities.
- Travel costs between these cities are known.
- Find the cheapest way from head office to branches in
different cities
London
Paris
Berlin
Rome
Barcelona
5
10
20
30
10
10
35 London
Paris
Berlin
Rome
Barcelona
5
10
10
10
Single Source Shortest Path Problem (SSSPP)
www.appmillers.com
- BFS
- Dijkstra’s Algorithm
- Bellman Ford
BFS - Breadth First Search
C
B
D G
A
E F
Level 1
Level 2
Level 3
A
B C
www.appmillers.com
Single Source Shortest Path Problem (SSSPP)
BFS for SSSPP
C
B
D G
A
E F
BFS
 enqueue any starting vertex
while queue is not empty
p = dequeue()
if p is unvisited
mark it visited
enqueue all adjacent unvisited vertices of p
update parent of adjacent vertices to curVertex
Queue A C D G E F
A
B
B C D G E F
null
A
A B B
C D
www.appmillers.com
Time and Space Complexity - BFS for SSSPP
create queue
enqueue any starting vertex
while queue is not empty
p = dequeue()
if p is unvisited
mark it visited
enqueue all adjacent unvisited vertices of p
update parent of adjacent vertices to curVertex
www.appmillers.com
O(1)
Time Complexity : O(E)
Space Complexity : O(V)
O(1)
O(V)
O(1)
O(1)
O(1)
O(adj)
O(1)
Why BFS not work with weighted Graph?
Graph Type BFS
Unweighted - undirected OK
Unweighted - directed OK
Positive - weighted - undirected X
Positive - weighted - directed X
Negative - weighted - undirected X
Negative - weighted - directed X
www.appmillers.com
A
B C
D E
H I
F G
10 50
30 5
6
7 20
9 30
A A
B B
www.appmillers.com
Why BFS not work with weighted Graph?
Why does DFS not work SSSPP?
A
B C
D E
I
F
DFS has the tendency to go “as far as possible” from source, hence it can never find “Shortest Path”
www.appmillers.com
Dijkstra’s Algorithm
1
1
2
3
4
Dijkstra’s Algorithm for SSSPP
A
C
D G
B E
F
2 1 4 9
5 7
3
8
Av0 6
Bv∞
Cv∞
Ev∞
Fv∞
Av0 Dv∞ Gv∞
2
Bv∞
5
Bv2
min
2
CCvv∞5
6
1
Bv2 3
Av0 Dv3
Ev5
1
Dv3
min
4
5
Cv5
min
8 Fv13
3 Ev5
min
9
Gv14
8 Fv13
min
Fv13
7
9
Gv14
www.appmillers.com
Dijkstra’s Algorithm for SSSPP
A
C
D G
B E
F
2 1 4 9
5
3
8
6
www.appmillers.com
7
A B
C D
E
-6
4
2
3
1 6
1
A path is called a negative cycle if:
There is a cycle (a cycle is a path of edges or vertices wherein a vertex is reachable from itself)
Total weight of cycle is a negative number
1 + 3 + (-6) = -2
www.appmillers.com
Dijkstra’s Algorithm with Negative Cycle
Dijkstra’s Algorithm with Negative Cycle
A B
C D
E
-6
4
2
3
1 6
1
We cannot never find a negative cycle in a graph
Path from A to B = 6 + 1 = -5
= -5+3+(-6)+1 = -7
= -7+3+(-6)+1 = -9
= -9+3+(-6)+1 = -11
www.appmillers.com
Bellman Ford Algorithm
1
1
2
3
4
-4
Single Source Shortest Path Algorithm
Graph Type BFS Dijkstra Bellman Ford
Unweighted - undirected OK OK OK
Unweighted - directed OK OK OK
Positive - weighted - undirected X OK OK
Positive - weighted - directed X OK OK
Negative - weighted - undirected X OK OK
Negative - weighted - directed X OK OK
Negative Cycle X X OK
www.appmillers.com
Bellman Ford Algorithm
Bellman Ford algorithm is used to find single source shortest path problem. If there is a negative cycle it catches it
and report its existence.
A B
C D
E
6
4
2
3
1 6
1
Bellman Ford Algorithm
www.appmillers.com
A B
C D
E
6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
Distance Matrix
Vertex Distance
A ∞
B ∞
C ∞
D ∞
E 0
∞ ∞
∞ ∞
0
www.appmillers.com
Bellman Ford Algorithm
A B
C D
E
6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1
Distance Parent
A ∞ ∞ -
B ∞ 4 E
C ∞ ∞ -
D ∞ 2 E
E 0 0 -
∞ 4 E
∞ 2 E
0
Distance Matrix
Vertex Distance
A ∞
B ∞
C ∞
D ∞
E 0
∞
∞
www.appmillers.com
Bellman Ford Algorithm
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
6
4
2
3
1
2
6
1
∞ 4 E
∞
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2
Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B
B ∞ 4 E 2+1=3 D
C ∞ ∞ - 2+2=4 D
D ∞ 2 E 2 E
E 0 0 - 0 -
7 B 3 D
4 D 2 E
0
Distance Matrix
Vertex Distance
Iteration 1
Distance Parent
A ∞ ∞ -
B ∞ 4 E
C ∞ ∞ -
D ∞ 2 E
E 0 0 -
www.appmillers.com
Bellman Ford Algorithm
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
6
4
2
3
1
2
6
1
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2 Iteration 3
Distance Parent Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B 3+3=6 B
B ∞ 4 E 2+1=3 D 3 D
C ∞ ∞ - 2+2=4 D 4 D
D ∞ 2 E 2 E 2 E
E 0 0 - 0 - 0
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2
Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B
B ∞ 4 E 2+1=3 D
C ∞ ∞ - 2+2=4 D
D ∞ 2 E 2 E
E 0 0 - 0 -
7 B
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
6 B 3 D
4 D 2 E
0
www.appmillers.com
Bellman Ford Algorithm
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2 Iteration 3 Iteration 4
Distance Parent Distance Parent Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B 3+3=6 B 6 B
B ∞ 4 E 2+1=3 D 3 D 3 D
C ∞ ∞ - 2+2=4 D 4 D 4 D
D ∞ 2 E 2 E 2 E 2 E
E 0 0 - 0 - 0 - 0 -
6 B 3 D
4 D 2 E
0
www.appmillers.com
Bellman Ford Algorithm
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Final Solution
Vertex Distance from E Path from E
A 6 E -> D -> B -> A
B 3 E -> D -> B
C 4 E -> D -> C
D 2 E -> D
E 0 0
6 B 3 D
3 D 2 E
0
www.appmillers.com
Bellman Ford Algorithm
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
A ∞
B ∞
C ∞
D ∞
E 0
∞ ∞
∞ ∞
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1
Distance Parent
A ∞ ∞ -
B ∞ 4 E
C ∞ ∞ -
D ∞ 2 E
E 0 0 -
∞ 4 E
∞ 2 E
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2
Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B
B ∞ 4 E 2+1=3 D
C ∞ ∞ - 2+2=4 D
D ∞ 2 E 2 E
E 0 0 - 0 -
7 B 3 D
4 D 2 E
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2 Iteration 3
Distance Parent Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B 3+3=6 B
B ∞ 4 E 2+1=3 D 3 D
C ∞ ∞ - 2+2=4 D 4 D
D ∞ 2 E 2 E 7+(-6)=1 A
E 0 0 - 0 - 0
6 B 3 D
4 D 1 A
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2 Iteration 3 Iteration 4
Distance Parent Distance Parent Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B 3+3=6 B 6 B
B ∞ 4 E 2+1=3 D 3 D 3 D
C ∞ ∞ - 2+2=4 D 4 D 4 D
D ∞ 2 E 2 E 7+(-6)=1 A 6+(-6)=0 A
E 0 0 - 0 - 0 - 0 -
6 B 3 D
4 D 0 A
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D -6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Distance Matrix
Vertex Distance
Iteration 1 Iteration 2 Iteration 3 Iteration 4 Iteration 5
Distance Parent Distance Parent Distance Parent Distance Parent Distance Parent
A ∞ ∞ - 4+3=7 B 3+3=6 B 6 B 4 B
B ∞ 4 E 2+1=3 D 3 D 3 D 0 D
C ∞ ∞ - 2+2=4 D 4 D 4 D 0 D
D ∞ 2 E 2 E 7+(-6)=1 A 6+(-6)=0 A 1 A
E 0 0 - 0 - 0 - 0 -
6 B 3 D
4 D 0 A
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
Edge Weight
A->C 6
A->D 6
B->A 3
C->D 1
D->C 2
D->B 1
E->B 4
E->D 2
Final Solution
Vertex Distance from E Path from E
A 6 E -> D -> B -> A
B 3 E -> D -> B
C 4 E -> D -> C
D 2 E -> D
E 0 0
6 B 3 D
4 D 2 E
0
www.appmillers.com
Bellman Ford with Negative Cycle
If the distance of destination vertex > (distance of
source vertex + weight between source and destination
vertex):
Update distance of destination vertex to (distance of
source vertex + weight between source and destination
vertex)
A B
C D
E
-6
4
2
3
1
2
6
1
A B
C D
E
-6
4
2
3
1
2
6
1
Why does Bellman Ford run V-1 times?
- If any node is achieved better distance in previous iteration, then that better distance is used to improve
distance of other vertices
∞ ∞
∞ ∞
0
76 43
- Identify worst case graph that can be given to us
A B C D E
10 20 30 40
A->B
B->C
C->D
∞ ∞ ∞ 0
A B C D
10 20 30
60 50 30
www.appmillers.com
BFS vs Dijkstra vs Bellman Ford
Graph Type BFS Dijkstra Bellman Ford
Unweighted - undirected OK OK OK
Unweighted - directed OK OK OK
Positive - weighted - undirected X OK OK
Positive - weighted - directed X OK OK
Negative - weighted - undirected X OK OK
Negative - weighted - directed X OK OK
Negative Cycle X X OK
www.appmillers.com
BFS Dijkstra Bellman Ford
Time complexity O(V2) O(V2) O(VE)
Space complexity O(E) O(V) O(V)
Implementation Easy Moderate Moderate
Limitation Not work for weighted graph Not work for negative cycle N/A
Unweighted graph
OK OK OK
Use this as time complexity is good and
easy to implement
Not use as implementation not
easy
Not use as time complexity is
bad
Weighted graph
X OK OK
Not supported Use as time complexity is better
than Bellman
Not use as time complexity is
bad
Negative Cycle
X X OK
Not supported Not supported Use this as others not
support
www.appmillers.com
BFS vs Dijkstra vs Bellman Ford
All Pairs Shortest Path
Problem (APSPP)
All Pair Shortest Path Problem
A single source problem is about finding a path between a given vertex (called source) to all other
vertices in a graph such that the total distance between them (source and destination) is minimum.
- Five offices in different cities.
- Travel costs between these cities are known.
- Find the cheapest way from head office to branches in
different cities
London
Paris
Berlin
Rome
Barcelona
5
10
20
30
10
10
35
London
Paris
Berlin
Rome
Barcelona
5
10
10
10
What is single source shortest path?
www.appmillers.com
All pair shortest path problem is about finding a path between every vertex to all other vertices in a
graph such that the total distance between them (source and destination) is minimum.
The problem:
- Five offices in different cities.
- Travel costs between these cities are known.
- Find the cheapest way to reach each office from every
other office
London
Paris
Berlin
Rome
Barcelona
5
10
20
30
10
10
35
All Pair Shortest Path Problem
www.appmillers.com
London
Paris
Berlin
Rome
Barcelona
5
10
10
London 10
Paris
Berlin
Rome
Barcelona
5
10
20 30
10
10
35
London
Paris
Berlin
Rome
Barcelona
5
20
10
10
London
Paris
Berlin
Rome
Barcelona
5
20
10
35
London
Paris
Berlin
Rome
Barcelona
5
20
10
35
London
Paris
Berlin
Rome
Barcelona
5
20
10
35
www.appmillers.com
All Pair Shortest Path Problem
Dijkstra
A B
C D
E
4
2
3
1
2
6
6
1
∞ ∞
∞ ∞
0
6 3
2
4
2
Source Vertex E Path
A E->D->B->A
B E->D->B
C E->D->C
D E->D
E -
www.appmillers.com
Dry Run for All Pair Shortest Path Problem
Dijkstra
A B
C D
E
4
2
3
1
2
6
6
1
∞ ∞
∞ 0
∞
4 1
2
Source Vertex E Path
A E->D->B->A
B E->D->B
C E->D->C
D E->D
E -
Source Vertex D Path
A D->B->A
B D->B
C D->C
D -
E N/A
www.appmillers.com
Dry Run for All Pair Shortest Path Problem
Dijkstra
A B
C D
E
4
2
3
1
2
6
6
1
Source Vertex E Path
A E->D->B->A
B E->D->B
C E->D->C
D E->D
E -
Source Vertex D Path
A D->B->A
B D->B
C D->C
D -
E N/A
Source Vertex C Path
A C->D->B->A
B C->D->B
C -
D C->D
E N/A
Source Vertex B Path
A B->A
B -
C B->A->C
D A->D
E N/A
Source Vertex A Path
A -
B A->D->B
C A->D->C
D A->D
E N/A
, BFS and Bellmand Ford
www.appmillers.com
Dry Run for All Pair Shortest Path Problem
Floyd Warshall Algorithm
1
1
2
3
4
-4
A B
D C
8
1
9
4
1
2
Given
A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 ∞ 0 ∞
D ∞ 2 9 0
If D[u][v] > D[u][viaX] + D[viaX][v]:
 D[u][v] = D[u][viaX] + D[viaX][v]
C -> B
If D[C][B] > D[C][A] + D[A][B]:
 D[C][B] = D[C][A] + D[A][B]
∞ > 4 + 8 = 12
Iteration 1
via A A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 4+8=12 0 4+1=5
D ∞ 2 9 0
C -> D
If D[C][D] > D[C][A] + D[A][D]:
 D[C][D] = D[C][A] + D[A][D]
∞ > 4 + 1 = 5
www.appmillers.com
Floyd Warshall Algorithm
A B
D C
8
1
9
4
1
2
Given
A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 ∞ 0 ∞
D ∞ 2 9 0
If D[u][v] > D[u][viaX] + D[viaX][v]:
 D[u][v] = D[u][viaX] + D[viaX][v]
A -> C
If D[A][C] > D[A][B] + D[B][C]:
 D[A][C] = D[A][B] + D[B][C]
∞ > 8 + 1 = 9
Iteration 1
via A A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 4+8=12 0 4+1=5
D ∞ 2 9 0
D -> C
If D[D][C] > D[D][B] + D[B][C]:
 D[D][C] = D[D][B] + D[B][C]
9 > 2 + 1 = 3
Iteration 2
via B A B C D
A 0 8 8+1=9 1
B ∞ 0 1 ∞
C 4 12 0 5
D ∞ 2 2+1=3 0
www.appmillers.com
Floyd Warshall Algorithm
A B
D C
8
1
9
4
1
2
Given
A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 ∞ 0 ∞
D ∞ 2 9 0
If D[u][v] > D[u][viaX] + D[viaX][v]:
 D[u][v] = D[u][viaX] + D[viaX][v]
Iteration 1
via A A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 4+8=12 0 4+1=5
D ∞ 2 9 0
Iteration 2
via B A B C D
A 0 8 8+1=9 1
B ∞ 0 1 ∞
C 4 12 0 5
D ∞ 2 2+1=3 0
Iteration 3
via C A B C D
A 0 8 9 1
B 1+4=5 0 1 1+4+1=
6
C 4 12 0 5
D 2+1+4
=7 2 3 0
Iteration 4
via D A B C D
A 0 1+2=3 9 1
B 5 0 1 6
C 4 4+1+2=
7 0 5
D 7 2 3 0
Final answer
A B C D
A 0 3 4 1
B 5 0 1 6
C 4 7 0 5
D 7 2 3 0
www.appmillers.com
Floyd Warshall Algorithm
A B
D C
8
1
9
4
1
2
Given
A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 ∞ 0 ∞
D ∞ 2 9 0
Iteration 1
via A A B C D
A 0 8 ∞ 1
B ∞ 0 1 ∞
C 4 4+8=12 0 4+1=5
D ∞ 2 9 0
Iteration 2
via B A B C D
A 0 8 8+1=9 1
B ∞ 0 1 ∞
C 4 12 0 5
D ∞ 2 2+1=3 0
Iteration 3
via C A B C D
A 0 8 9 1
B 1+4=5 0 1 1+4+1=
6
C 4 12 0 5
D 3+4=7 2 3 0
Iteration 4
via D A B C D
A 0 1+2=3 3+1=4 1
B 5 0 1 6
C 4 5+2=7 0 5
D 7 2 3 0
Final answer
A B C D
A 0 3 4 1
B 5 0 1 6
C 4 7 0 5
D 7 2 3 0
- The vertex is not reachable
- Two vertices are directly connected
 This is the best solution
 It can be improved via other vertex
- Two vertices are connected via other vertex
E
www.appmillers.com
Why Floyd Warshall Algorithm?
Floyd Warshall negative cycle
A B
D C
-8
1
9
4
1
2
- To go through cycle we need to go via negative cycle participating vertex at least twice
-8+1+4=-3
- FW never runs loop twice via same vertex
- Hence, FW can never detect a negative cycle
www.appmillers.com
Which algorithm to use for APSP?
Graph Type BFS Dijkstra Bellman Ford Floyd Warshall
Unweighted - undirected OK OK OK OK
Unweighted - directed OK OK OK OK
Positive - weighted - undirected X OK OK OK
Positive - weighted - directed X OK OK OK
Negative - weighted - undirected X OK OK OK
Negative - weighted - directed X OK OK OK
Negative Cycle X X OK X
www.appmillers.com
Which algorithm to use for APSP?
BFS Dijkstra Bellman Ford Floyd Warshall
Time complexity O(V3) O(V3) O(EV2) O(V3)
Space complexity O(EV) O(EV) O(V2) O(V2)
Implementation Easy Moderate Moderate Moderate
Limitation Not work for weighted graph Not work for negative
cycle N/A Not work for negative
cycle
Unweighted graph
OK OK OK OK
Use this as time complexity is
good and easy to implement
Not use as priority queue
slows it
Not use as time
complexity is bad Can be used
Weighted graph
X OK OK OK
Not supported Can be used
Not use as time
complexity is bad Can be preferred as
implementation easy
Negative Cycle
X X OK X
Not supported Not supported Use this as others not
support No supported
www.appmillers.com
AppMillers
www.appmillers.com
Minimum Spanning Tree
A Minimum Spanning Tree (MST) is a subset of the edges of connected, weighted and undirected graph which :
- Connects all vertices together
- No cycle
- Minimum total edge
Real life problem
- Connect five island with bridges
- The cost of bridges between island varies based on different factors
- Which bridge should be constructed so that all islands are accessible and the cost is minimum
5
35
10
20
10
15
25
5
10
10
15
AppMillers
www.appmillers.com
Minimum Spanning Tree
Real life problem
5
35
10
20
10
15
25
5
10
10
15
Minimum spanning Tree
5
20
10
15
Single source shortest path
AppMillers
www.appmillers.com
Disjoint Set
It is a data structure that keeps track of set of elements which are partitioned into a number of
disjoint and non overlapping sets and each sets have representative which helps in identifying
that sets.
- Make Set
- Union
- Find Set
AppMillers
www.appmillers.com
Disjoint Set
makeSet(N) : used to create initial set
A B C D E
union(x,y): merge two given sets
union(A,B)
AB C D E
union(A, E)
ABE C D
findSet(x): returns the set name in which this element is there
findSet(B)
findSet(E)
Kruskal’s Algorithm
1
3
2
4
It is a greedy algorithm
It finds a minimum spanning tree for weighted undirected graphs in two steps
- Add increasing cost edges at each step
- Avoid any cycle at each step
A B
C D
E
15
20
5
8
10
13
6
A B
C D
E
15
5
8
6
Kruskal’s Algorithm
www.appmillers.com
Kruskal’s Algorithm Pseudocode
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
5
8
6
Kruskal(G)
for each vertex
    makeSet(v)
sort each edge in non decreasing order by weight
for each edge (u, v)
    if findSet(u) ≠ findSet(v)      
     union(u, v)
     cost = cost + edge(u,v)
A B C D E
Cost = 0
ABCD ABCDE AB CD
+5 +6 +8 +15 = 34
www.appmillers.com
Kruskal(G)
for each vertex
    makeSet(v)
sort each edge in non decreasing order by weight
for each edge (u, v)
    if findSet(u) ≠ findSet(v)       
     union(u, v)
     cost = cost + edge(u,v)
O(v)
O(eloge)
O(ev)
O(e)
O(1)
O(v)
O(1)}
Time complexity : O(V+ElogE+EV) = O(Elog(E))
Space complexity : O(V+E)
www.appmillers.com
Time and Space Complexity of Kruskal’s Algorithm
Prim’s Algorithm
It is a greedy algorithm
It finds a minimum spanning tree for weighted undirected graphs in following ways
1. Take any vertex as a source set its weight to 0 and all other vertices’ weight to infinity
2. For every adjacent vertices if the current weight is more than current edge then we set it to current edge
3. Then we mark current vertex as visited
4. Repeat these steps for all vertices in increasing order of weight
B D
C E
A
10
20
5
8
15 30
6
0
∞
∞
∞
∞
10
20
5
156 8
B D
C E
A
10 5
6 8
0
www.appmillers.com
Kruskal vs Prim
Kruskal
- Concentrates on Edges
- Finalize edge in each iteration
A B
C D
E
15
20
5
8
10 13
6
A B
5 A B
C D
5
8
6
A B
C D
E
15
5
8
6 C D
6
A B
5
Prim’s
- Concentrates on Vertices
- Finalize Vertex in each iteration
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
www.appmillers.com
Kruskal
- Concentrates on Edges
- Finalize edge in each iteration
A B
C D
E
15
20
5
8
10 13
6
A B
5 A B
C D
5
8
6
A B
C D
E
15
5
8
6 C D
6
A B
5
Prim’s
- Concentrates on Vertices
- Finalize Vertex in each iteration
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
20
5
8
10 13
6
www.appmillers.com
Kruskal vs Prim
- Landing cables
- TV Network
- Tour Operations
- LAN Networks
- A network of pipes for drinking water or natural gas.
- An electric grid
- Single-link Cluster
Kruskal Applications
Prim’s Applications
- Network for roads and Rail tracks connecting all the cities.
- Irrigation channels and placing microwave towers
- Designing a fiber-optic grid or ICs.
- Traveling Salesman Problem.
- Cluster analysis.
- Pathfinding algorithms used in AI(Artificial Intelligence).
Kruskal vs Prim
Tree and Graph
Interview Questions
Tree and Graph Interview Questions
www.appmillers.com
Route Between Nodes
Problem Statement:
Given a directed graph and two nodes (S and E), design an algorithm to find out whether there is a route from S to E.
C B
G
D
A
E
F
H J
I
A —> E
A —> J
A —> I
False
True
True
www.appmillers.com
Problem Statement:
Given a directed graph and two nodes (S and E), design an algorithm to find out whether there is a route from S to E.
C B
G
D
A
E
F
H J
I
Pseudocode
- Create function with two parameters start and end nodes
- Create queue and enqueue start node to it
- Find all the neighbors of the just enqueued node and enqueue
them into the queue
- Repeat this process until the end of elements in graph
- If during the above process at some point in time we encounter
the destination node, we return True.
- Mark visited nodes as visited
www.appmillers.com
Route Between Nodes
Problem Statement:
Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search
tree with minimal height.
4 7 9
8
5
3
1 6
2
1 2 3 4 5 6 7 8 9
Root Node
Left Subtree Right Subtree
www.appmillers.com
Minimal Tree
Problem Statement:
Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (i e , if
you have a tree with depth D, you’ll have D linked lists)
5 6 7
3
1
2
4
1 None
001
2 111
001
3 None
111
4 111
001
5 222
111
6 333
222
7 None
333
Level 1
Level 2
Level 3
www.appmillers.com
List of Depths
Problem Statement:
Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each
depth (i e , if you have a tree with depth D, you’ll have D linked lists)
5 6 7
3
1
2
4 4 111
001
custDict
Keys Values
3
2
1 5 222
111
6 333
222
7
333
1
001
2 111
001
3
111
Pre Order Traversal
www.appmillers.com
List of Depths
Check Balanced
Problem Statement:
Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined
to be a tree such that the heights of the two subtrees of any node never differ by more than one.
N1
N6
N2 N3
N4 N5
Balanced Binary Tree
www.appmillers.com
Check Balanced
Problem Statement:
Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined
to be a tree such that the heights of the two subtrees of any node never differ by more than one.
N1
N2
N4 N5
Balanced Binary Tree
www.appmillers.com
Check Balanced
Problem Statement:
Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined
to be a tree such that the heights of the two subtrees of any node never differ by more than one.
N1
N6
N2 N3
N4 N5
- The right subtree is balanced
- The left subtree is balanced
- The difference between the height of the left subtree
and the right subtree is at most 1
The Binary Tree is Balanced if:
www.appmillers.com
Validate BST
Problem Statement:
Implement a function to check if a binary tree is a Binary Search Tree.
2
1 4
The Binary Tree is Binary Search Tree if:
- The left subtree of a node contains only nodes with keys less than the node’s key
- The right subtree of a node contains only nodes with keys greater than the node’s key
- These conditions are applicable for both left and right subtrees
4
2
1 3
5
True
False
www.appmillers.com
Validate BST
Problem Statement:
Implement a function to check if a binary tree is a Binary Search Tree.
3
5
2 8
1 9
-∞ <= <= ∞
-∞ <= <= 3
-∞ <= <= 2
3<= <= ∞
-∞<= <= 8 <= <= ∞
Min Max
www.appmillers.com
Validate BST
Problem Statement:
Implement a function to check if a binary tree is a Binary Search Tree.
3
5
2 8
1 9
-∞ <= <= ∞
-∞ <= <= 3
-∞ <= <= 2
3<= <= ∞
-∞<= <= 8 <= <= ∞
Min Max
www.appmillers.com
Successor
Problem Statement:
Write an algorithm to find the next node (i.e in-order successor) of given node in a binary search tree. You may assume
that each node has a link to its parent.
4
5
2 8
1 3 9
In-order successor of 1 is 2
In-order successor of 3 is 4
In-order successor of 2 is 3
www.appmillers.com
Successor
Problem Statement:
Write an algorithm to find the next node (i.e in-order successor) of given node in a binary search tree. You may assume
that each node has a link to its parent.
4
5
2 8
1 3 9
- If right subtree of node is not None, then successor lies in right subtree.
- If right subtree of node is None, then successor is one of the ancestors.
www.appmillers.com
Build Order
Problem Statement:
b
f
a c
d e
Input:
You are given a list of projects and a list of dependencies (which is a list of pairs of projects, where the second project is
dependent on the first project). All of a project's dependencies must be built before the project is. Find a build order that will
allow the projects to be built. If there is no valid build order, return an error.
Projects : a, b, c, d, e, f
Dependencies: (a, d), (f, b), (b, d), (f, a), (d, c)
Output:
e, f, a, b, d, c
www.appmillers.com
Build Order
Problem Statement:
b
f
a c
d e
You are given a list of projects and a list of dependencies (which is a list of pairs of projects, where the second project is
dependent on the first project). All of a project's dependencies must be built before the project is. Find a build order that will
allow the projects to be built. If there is no valid build order, return an error.
Find nodes with dependencies
a, b, c, d
Find nodes without dependencies
e, f
Find order by taking out nodes without dependencies.
www.appmillers.com
First Common Ancestor
Problem Statement:
Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional
nodes in a data structure. NOTE: This is not necessarily a binary search tree.
55
77
22 99
44
90
33
35 88 95
54
First Common Ancestor of 33 and 88
44
www.appmillers.com
First Common Ancestor
Problem Statement:
55
77
22 99
44
90
Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional
nodes in a data structure. NOTE: This is not necessarily a binary search tree.
33
35 88 95
54
findNodeinTree()
Return root (44)
findNodeinTree(88, left-44)
findNodeinTree(33, left-44)
True
True
findNodeinTree(88, left-22)
findNodeinTree(33, left-22)
True
False
www.appmillers.com
First Common Ancestor
Problem Statement:
55
77
22 99
44
90
Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional
nodes in a data structure. NOTE: This is not necessarily a binary search tree.
33
35 88 95
54
www.appmillers.com
Greedy Algorithms
www.appmillers.com
What is Greedy Algorithm?
- It is an algorithmic paradigm that builds the solution piece by piece
- In each step it chooses the piece that offers most obvious and immediate benefit
- It fits perfectly for those solutions in which local optimal solutions lead to global solution
Local solutions
Global solution
- Insertion Sort
- Selection Sort
- Topological Sort
- Prim’s Algorithm
- Kruskal Algorithm
- Activity Selection Problem
- Coin change Problem
- Fractional Knapsack Problem
www.appmillers.com
What is Greedy Algorithm?
- Insertion Sort
- Selection Sort
- Topological Sort
- Prim’s Algorithm
- Kruskal Algorithm
Greedy Algorithms
www.appmillers.com
Greedy Algorithms
Insertion Sort
Sorted array Unsorted array
5 3 4 7 2 8 6 9 1
4 5 7 8 9
Sorted array Unsorted array
2 3 6 1
www.appmillers.com
Selection Sort
5 7 4 3 8 6 1 9 2
Sorted array Unsorted array
min
1 2 4 8 6 5 9 7
Sorted array Unsorted array
3
Greedy Algorithms
www.appmillers.com
Topological Sort
Stack
C
A
E
H
H
E
C
A A C E H
www.appmillers.com
Greedy Algorithms
It is a greedy algorithm
It finds a minimum spanning tree for weighted undirected graphs in following ways
1. Take any vertex as a source set its weight to 0 and all other vertices’ weight to infinity
2. For every adjacent vertices if the current weight is more than current edge then we set it
to current edge
3. Then we mark current vertex as visited
4. Repeat these steps for all vertices in increasing order of weight
B D
C E
A
10
20
5
8
15 30
6
0
∞
∞
∞
∞
10
20
5
156 8
B D
C E
A
10 5
6 8
0
Prims Algorithm
www.appmillers.com
Greedy Algorithms
It is a greedy algorithm
It finds a minimum spanning tree for weighted undirected graphs in two ways
- Add increasing cost edges at each step
- Avoid any cycle at each step
A B
C D
E
15
20
5
8
10 13
6
A B
C D
E
15
5
8
6
Kruskal’s Algorithm
www.appmillers.com
Greedy Algorithms
Activity Selection Problem
 Given N number of activities with their start and end times. We need to select the maximum
number of activities that can be performed by a single person, assuming that a person can only
work on a single activity at a time.
Activity A1 A2 A3 A4 A5 A6
Start 0 3 1 5 5 8
Finish 6 4 2 8 7 9
Activity A3 A2 A1 A5 A4 A6
Start 1 3 0 5 5 8
Finish 2 4 6 7 8 9
2 Activities
4 Activities
www.appmillers.com
Activity selection problem
Sort activities based on finish time
Select first activity from sorted array and print it
For all remainin activities:
If the start time of this activity is greater or equal to the
finish time of previously selected activity then select this
activity and print it
www.appmillers.com
Coin Change Problem
You are given coins of different denominations and total amount of money. Find the minimum
number of coins that you need yo make up the given amount.
Example 1
Total amount : 70
Infinite supply of denominations : {1,2,5,10,20,50,100,1000}
Answer: 2 —> 50 + 20 = 70
Example 2
Total amount : 122
Answer: 3 —> 100 + 20 + 2 = 121
www.appmillers.com
Coin Change Problem
You are given coins of different denominations and total amount of money. Find the minimum
number of coins that you need yo make up the given amount.
Total amount : 2035
Infinite supply of denominations : {1,2,5,10,20,50,100,1000}
Answer: 5
2035 - 1000 = 1035 Result : 1000
1035 - 1000 = 35
35 - 20 = 15
15 - 10 = 5
5 - 5 = 0
, 1000 , 20 , 10 , 5
www.appmillers.com
Coin Change Problem
Find the biggest coin that is less than given total number
Add coin to the result and subtract coin from total number
If V is equal to zero:
 Then print result
else:
 Repeat Step 2 and 3
www.appmillers.com
Fractional Knapsack Problem
Given a set of items, each with a weight and a value, determine the number of each item to include
in a collection so that the total weight is less than or equal to a given limit and the total value is as
large as possible.
30 kg
10 kg, Value : 20
20 kg, Value : 10
10 kg, Value : 30
www.appmillers.com
Fractional Knapsack Problem
Given a set of items, each with a weight and a value, determine the number of each item to include
in a collection so that the total weight is less than or equal to a given limit and the total value is as
large as possible.
50 kg
20 kg, Value : 100 30 kg, Value : 120 10 kg, Value : 60
100 + 120 = 220
100 / 20 = 5 120 / 30 = 4 60 / 10 = 6
60 + 100 + 120*2/3 = 240
www.appmillers.com
Fractional Knapsack Problem
Given a set of items, each with a weight and a value, determine the number of each item to include
in a collection so that the total weight is less than or equal to a given limit and the total value is as
large as possible.
50 kg
100 + 120 = 220
20 kg, Value : 100
100 / 20 = 5
30 kg, Value : 120
120 / 30 = 4
10 kg, Value : 60
60 / 10 = 6
60 + 100 + 120*2/3 = 240
www.appmillers.com
Fractional Knapsack Problem
Calculate the density or ratio for each item
Sort items based on this ratio
Take items with the highest ratio sequentially until weight allows
Add the next item as much (fractional) as we can
www.appmillers.com
What is Divide and Conquer Algorithm?
 Divide and conquer is an algorithm design paradigm which works by recursively breaking down a problem
into subproblems of similar type, until these become simple enough to be solved directly. The solutions to the
subproblems are then combined to give a solution to the original problem.
Example : Developing a website
Website
Module 1 Module 2 Module 3
Sub M1 Sub M2 Sub M3 Sub M4 Sub M5
Func 1
Func 2
Func 3
Func 4
Func 1
Func 2
Func 3
Func 4
www.appmillers.com
Dynamic Programming
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
Example 1
- N = 4
- Number of ways = 4
- Explanation : There are 4 ways we can express N. {4},{1,3},{3,1},{1,1,1,1}
Example 2
- N = 5
- Number of ways = 6
- Explanation : There are 6 ways we can express N. {4,1},{1,4},{1,3,1},{3,1,1},{1,1,3},{1,1,1,1,1}
Dynamic Programming - Number Factor
www.appmillers.com
NumberFactor(N)
 If N in (0,1,2) return 1
 If N = 3 return 2
 Else
 return NumberFactor(N-1) + NumberFactor(N-3) + NumberFactor(N-4)
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(8)
NumberFactor(7) NumberFactor(4)
NumberFactor(6)
NumberFactor(4)
NumberFactor(3)
NumberFactor(5)
NumberFactor(4)
NumberFactor(2)
NumberFactor(1)
NumberFactor(3)
NumberFactor(1)
NumberFactor(0)
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(8)
NumberFactor(7) NumberFactor(4)
NumberFactor(6)
NumberFactor(4)
NumberFactor(3)
NumberFactor(5)
NumberFactor(4)
NumberFactor(2)
NumberFactor(1)
NumberFactor(3)
NumberFactor(1)
NumberFactor(0)
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N):
 If N in (0,1,2) return 1
 If N = 3 return 2
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 return rec1 + rec2 + rec3
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N, dp):

 If N in (0,1,2) return 1
 If N = 3 return 2
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 return rec1 + rec2 + rec3
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N, dp):

 If N in (0,1,2) return 1
 If N = 3 return 2
 Elif N in dp return dp[N]
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 return rec1 + rec2 + rec3
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N, dp):

 If N in (0,1,2) return 1
 If N = 3 return 2
 Elif N in dp return dp[N]
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 dp[N] = rec1 + rec2 + rec3
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N, dp):

 If N in (0,1,2) return 1
 If N = 3 return 2
 Elif N in dp return dp[N]
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 dp[N] = rec1 + rec2 + rec3
 return dp[N]
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NumberFactor(N, dp):

 If N in (0,1,2) return 1
 If N = 3 return 2
 Elif N in dp return dp[N]
 Else
 rec1 = NumberFactor(N-1)
 rec2 = NumberFactor(N-3)
 rec3 = NumberFactor(N-4)
 dp[N] = rec1 + rec2 + rec3
 return dp[N]
Step 1
Step 2
Step 3
Step 4
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF5+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF4+NF2+NF1 NF5+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF3+NF2+NF0 NF4+NF2+NF1 NF5+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 NF4+NF2+NF1 NF5+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 NF5+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 6+2+1=9 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 6+2+1=9 9+4+2=15
Top Down Approach
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF3+NF1+NF0
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF3+NF1+NF0 NF4+NF2+NF1
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF3+NF1+NF0 NF4+NF2+NF1 NF6+NF3+NF2
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 NF3+NF1+NF0 NF4+NF2+NF1 NF6+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 NF4+NF2+NF1 NF6+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 NF6+NF3+NF2 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 6+2+1=9 NF6+NF4+NF3
NF(0) NF(1) NF(2) NF(3) NF(4) NF(5) NF(6) NF(7)
1 1 1 2 2+1+1=4 4+1+1=6 6+2+1=9 9+4+2=15
Bottom Up Approach
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
numberFactor(n)
 tb = {1,1,1,2}
 for i in range(4, n+1):
 tb.append(tb[i-1]+tb[i-3]+tb[i-4])
 return tb[n]
Bottom Up Approach
Dynamic Programming - Number Factor
www.appmillers.com
Problem Statement:
Given N, find the number of ways to express N as a sum of 1, 3 and 4.
Dynamic Programming - House Robber
Problem Statement:
- Maximum amount = 41
- Houses that are stolen : 7, 30, 4
Answer
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
Example 1
6 7 1 30 8 2 4
Option1 = 6 + f(5)
Option2 = 0 + f(6)
Max(Option1, Option2)
www.appmillers.com
maxValueHouse(houses, currentHouse)
 If currentHouse > length of houses
 return 0
 Else
 stealFirstHouse = currentHouse + maxValueHouse(houses, currentHouse+2)
 skipFirstHouse = maxValueHouse(houses, currentHouse+1)
 return max(stealFirstHouse, skipFirstHouse)
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
maxValueHouse(0)
maxValueHouse(2) maxValueHouse(1)
maxValueHouse(4) maxValueHouse(3) maxValueHouse(3) maxValueHouse(2)
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
maxValueHouse(0)
maxValueHouse(2) maxValueHouse(1)
maxValueHouse(4) maxValueHouse(3) maxValueHouse(3) maxValueHouse(2)
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
maxValueHouse(houses, currentHouse)
 If currentHouse > length of houses
 return 0
 Else
 stealFirstHouse = currentHouse + maxValueHouse(houses, currentHouse+2)
 skipFirstHouse = maxValueHouse(houses, currentHouse+1)
 return max(stealFirstHouse, skipFirstHouse)
maxValueHouse(houses, currentHouse, dp):
 If currentHouse > length of houses
 return 0
 Else
 stealFirstHouse = currentHouse + maxValueHouse(houses, currentHouse+2)
 skipFirstHouse = maxValueHouse(houses, currentHouse+1)
 return max(stealFirstHouse, skipFirstHouse)
Step 1
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
maxValueHouse(houses, currentHouse, dp):
 If currentHouse > length of houses
 return 0
 Else
 If currentHouse not in dp:
 stealFirstHouse = currentHouse + maxValueHouse(houses, currentHouse+2)
 skipFirstHouse = maxValueHouse(houses, currentHouse+1)
 return max(stealFirstHouse, skipFirstHouse)
Step 1
Step 2
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
maxValueHouse(houses, currentHouse, dp):
 If currentHouse > length of houses
 return 0
 Else
 If currentHouse not in dp:
 stealFirstHouse = currentHouse + maxValueHouse(houses, currentHouse+2)
 skipFirstHouse = maxValueHouse(houses, currentHouse+1)
 dp[currentHouse] = max(stealFirstHouse, skipFirstHouse)
 return dp[currentHouse]
Step 1
Step 2
Step 3
Step 4
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1)
H0 H1 H2 H3 H4 H5 H6
6 7 1 30 8 2 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2)
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3)
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4)
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5)
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6)
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6) max(H6+HR8, HR7)
Top Down Approach
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6) max(H6+HR8, HR7)
H0 H1 H2 H3 H4 H5 H6
6 7 1 30 8 2 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6) 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(2+0, 4)=4 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(8+4,4)=12 4 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) 12 4 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) 34 12 4 4
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6)
41 41 34 34 12 4 4
Top Down Approach
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6) max(H6+HR8, HR7) 0 0
H0 H1 H2 H3 H4 H5 H6
6 7 1 30 8 2 4
Bottom Up Approach
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) max(H5+HR7, HR6) 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) max(H4+HR6, HR5) 4 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) max(H3+HR5, HR4) 12 4 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) max(H2+HR4, HR3) 34 12 4 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) max(H1+HR3, HR2) 34 34 12 4 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
max(H0+HR2, HR1) 41 34 34 12 4 4 0 0
HR(0) HR(1) HR(2) HR(3) HR(4) HR(5) HR(6) HR(7) HR(8)
41 41 34 34 12 4 4 0 0
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
Dynamic Programming - House Robber
www.appmillers.com
Bottom Up Approach
houseRobberBU(houses, currentIndex)
 tempAr = [0]*(length(houses)+2)
 for i in length(houses)-1 until -1
 tempAr[i] = max(houses[i]+tempAr[i+2], tempAr[i+1])
 return tempAr[0]
www.appmillers.com
Dynamic Programming - House Robber
Problem Statement:
- Given N number of houses along the street with some amount of money
- Adjacent houses cannot be stolen
- Find the maximum amount that can be stolen
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
Example 1
- S1 = “catch”
- S2 = “carch”
- Output = 1
- Explanation : Replace “r” with “t”
Example 2
- S1 = “table”
- S2 = “tbres”
- Output = 3
- Explanation : Insert “a” to second position, replace “r” with “l” and delete “s”
Dynamic Programming - Convert String
www.appmillers.com
findMinOperation(s1, s2, index1, index2):
 If index1 == len(s1)
 return len(s2)-index2
 If index2 == len(s2)
 return len(s1)-index1
 If s1[index1] == s2[index2]
 return findMinOperation(s1, s2, index1+1, index2+1)
 Else
 deleteOp = 1 + findMinOperation(s1, s2, index1, index2+1)
 insertOp = 1 + findMinOperation(s1, s2, index1+1, index2)
 replaceOp = 1 + findMinOperation(s1, s2, index1+1, index2+1)
 return min(deleteOp, insertOp, replaceOp)
Dynamic Programming - Convert String
www.appmillers.com
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
minOper(0,0)
minOper(1,0) minOper(0,1) minOper(1,1)
minOper(2,0)
minOper(1,1)
minOper(2,1)
minOper(1,1)
minOper(0,2)
minOper(1,2)
minOper(2,1)
minOper(1,2)
minOper(2,2)
Dynamic Programming - Convert String
www.appmillers.com
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
minOper(0,0)
minOper(1,0) minOper(0,1) minOper(1,1)
minOper(2,0)
minOper(1,1)
minOper(2,1)
minOper(1,1)
minOper(0,2)
minOper(1,2)
minOper(2,1)
minOper(1,2)
minOper(2,2)
Dynamic Programming - Convert String
www.appmillers.com
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
findMinOperation(s1, s2, index1, index2, dp[][])
 if index1 == s1.length
 return s2.length-index2
 if index2 == len(s2)
 return len(s1)-index1
 if s1[index1] == s2[index2]
 return findMinOperation(s1, s2, index1+1, index2+1, tempDict)
 else:
 dictKey = str(index1)+str(index2)
 if dictKey not in tempDict:
 deleteOp = 1 + findMinOperation(s1, s2, index1, index2+1, tempDict)
 insertOp = 1 + findMinOperation(s1, s2, index1+1, index2, tempDict)
 replaceOp = 1 + findMinOperation(s1, s2, index1+1, index2+1, tempDict)
 tempDict[dictKey] = min (deleteOp, insertOp, replaceOp)
 return tempDict[dictKey]
Step 1
Step 2
Step 3 Step 4
Top Down Approach
Dynamic Programming - Convert String
www.appmillers.com
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
if(dp[i1][i2] == null) {
   if(i1 == s1.length()) // if we have reached the end of s1, then insert all the remaining characters of s2
   dp[i1][i2] = s2.length() - i2;
  
   else if(i2 == s2.length()) // if we have reached the end of s2, then delete all the remaining characters of s1
   dp[i1][i2] = s1.length() - i1;
  
   else if(s1.charAt(i1) == s2.charAt(i2)) // If the strings have a matching character, recursively match for the remaining lengths.
   dp[i1][i2] = findMinOperationsTD(dp, s1, s2, i1+1, i2+1);

Bottom Up Approach
def findMinOperationBU(s1, s2, tempDict):
 for i1 in range(len(s1)+1):
 dictKey = str(i1)+'0'
 tempDict[dictKey] = i1
 for i2 in range(len(s2)+1):
 dictKey = '0'+str(i2)
 tempDict[dictKey] = i2

 for i1 in range(1, len(s1)+1):
 for i2 in range(1, len(s2)+1):
 if s1[i1-1] == s2[i2-1]:
 dictKey = str(i1)+str(i2)
 dictKey1 = str(i1-1)+str(i2-1)
 tempDict[dictKey] = tempDict[dictKey1]
 else:
 dictKey = str(i1)+str(i2)
 dictKeyD = str(i1-1)+str(i2)
 dictKeyI = str(i1)+str(i2-1)
 dictKeyR = str(i1-1)+str(i2-1)
 tempDict[dictKey] = 1 + min(tempDict[dictKeyD], min(tempDict[dictKeyI],tempDict[dictKeyR]))
 dictKey = str(len(s1))+str(len(s2))
 return tempDict[dictKey]
Dynamic Programming - Convert String
www.appmillers.com
Problem Statement:
- S1 and S2 are given strings
- Convert S2 to S1 using delete, insert or replace operations
- Find the minimum count of edit operations
A Recipe for Problem
Solving
www.appmillers.com
A Recipe for Problem Solving
Algorithm : is a set of steps fo accomplish a certain task
www.appmillers.com
A Recipe for Problem Solving
5 STEPS FOR PROBLEM SOLVING �
www.appmillers.com
A Recipe for Problem Solving
UNDERSTAND THE PROBLEM
EXPLORE EXAMPLES
BREAK IT DOWN
SOLVE / SIMPLIFY
LOOK BACK REFACTOR
www.appmillers.com
A Recipe for Problem Solving
Step 1 - UNDERSTAND THE PROBLEM
www.appmillers.com
Step 1 - UNDERSTAND THE PROBLEM
www.appmillers.com
Step 1 - UNDERSTAND THE PROBLEM
1. Can we restate the problem in our own words?
2. What are the inputs that go into the problem?
3. What are the outputs that come from the problem?
4. Can the outputs be determined from the inputs? In other
words do we have enough information to solve this problem?
5. What should I label the important piece of data that are the
part of a problem?
www.appmillers.com
Step 1 - UNDERSTAND THE PROBLEM
Write a function that takes two numbers and returns their sum
1. Can we restate the problem in our own words?
2. What are the inputs that go into the problem?
3. What are the outputs that come from the problem?
4. Can the outputs be determined from the inputs? In other words do
we have enough information to solve this problem?
5. What should I label the important piece of data that are the part of a
problem?
Implement addition
Integer? Float? Or?
Integer? Float? Or?
Yes
Add, Sum
www.appmillers.com
UNDERSTAND THE PROBLEM
EXPLORE EXAMPLES
www.appmillers.com
A Recipe for Problem Solving
Step 2 - EXPLORE EXAMPLES
www.appmillers.com
Step 2 - EXPLORE EXAMPLES
1. Start with simple examples
2. Progress to more complex examples
3. Explore examples with empty
4. Explore the examples with invalid inputs
www.appmillers.com
Step 2 - EXPLORE EXAMPLES
Write a function that takes in a string and
returns the count of each character in the string
www.appmillers.com
Step 3 - BREAK IT DOWN
Write out the steps that you need to take
www.appmillers.com
SOLVE / SIMPLIFY
Solve the Problem
If you cannot…
Simplify the Problem
www.appmillers.com
SOLVE / SIMPLIFY
Simplify the Problem
• Find the core difficulty
• Temporarily ignore that difficulty
• Write a simplified solution
• Then incorporate that difficulty
www.appmillers.com
LOOK BACK REFACTOR
• Can we check the result?
• Can we drive the result differently?
• Can we understand it at a glance?
• Can we use the result or method for some other problem?
• Can you improve the performance of your solution?
• How do other people solve this problem?
www.appmillers.com
Summarize
UNDERSTAND THE PROBLEM
EXPLORE EXAMPLES
BREAK IT DOWN
SOLVE / SIMPLIFY
LOOK BACK REFACTOR
www.appmillers.com
